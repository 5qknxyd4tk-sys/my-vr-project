<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D GLB Explorer Pro</title>
    <style>
        :root {
            --primary: #007AFF;
            --bg-light: rgba(255, 255, 255, 0.85);
            --border: rgba(0, 0, 0, 0.08);
            --text: #333;
            --shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #ffffff; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; 
            color: var(--text); 
            user-select: none; 
            -webkit-user-select: none; 
            touch-action: none;
        }

        /* 로딩 화면 */
        #landing-page {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: #fff; z-index: 200; gap: 30px;
        }
        
        .option-container {
            display: flex; gap: 20px; flex-wrap: wrap; justify-content: center;
        }

        .upload-box {
            border: 2px dashed #ddd; padding: 40px; border-radius: 24px; text-align: center;
            background: #fafafa; cursor: pointer; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            width: 220px;
        }
        .upload-box:hover { border-color: var(--primary); background: #f0f7ff; transform: translateY(-4px); }
        .upload-box.project-btn { border-style: solid; background: #fff; box-shadow: var(--shadow); border-color: var(--border); }
        .upload-box.project-btn:hover { border-color: var(--primary); }

        .upload-box h2 { margin: 0; font-size: 16px; font-weight: 700; color: #222; }
        .upload-box p { font-size: 12px; color: #888; margin-top: 8px; }
        
        /* UI 패널 */
        .panel {
            position: absolute; left: 20px; width: 240px;
            background: var(--bg-light); backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px);
            border-radius: 16px; box-shadow: var(--shadow);
            border: 1px solid rgba(255,255,255,0.4);
            display: flex; flex-direction: column; transition: all 0.3s; overflow: hidden;
            z-index: 20;
        }
        
        .panel-header {
            padding: 12px 16px; background: rgba(0,0,0,0.03); cursor: move;
            display: flex; justify-content: space-between; align-items: center;
            font-weight: 700; font-size: 11px; color: #666; letter-spacing: 0.05em;
            border-bottom: 1px solid var(--border);
        }
        .panel-content { padding: 16px; display: flex; flex-direction: column; gap: 14px; }
        .panel.minimized .panel-content { display: none; }
        
        #env-panel { top: 80px; }
        #cut-panel { top: 400px; }

        /* 도움말 패널 */
        #help-panel {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 320px; display: none; max-height: 80vh; overflow-y: auto;
        }
        .help-grid { display: grid; grid-template-columns: 1fr 2fr; gap: 10px; font-size: 12px; }
        .help-section { font-weight: 800; color: var(--primary); grid-column: span 2; margin-top: 10px; border-bottom: 1px solid var(--border); padding-bottom: 4px; }
        .key { background: #eee; padding: 2px 6px; border-radius: 4px; font-weight: 700; text-align: center; border-bottom: 2px solid #ccc; }

        /* 컨트롤 요소 */
        button {
            background: #fff; border: 1px solid var(--border); color: #555; padding: 8px 12px; border-radius: 8px;
            cursor: pointer; font-size: 11px; font-weight: 600; transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.02);
            white-space: nowrap;
        }
        button:hover { background: #f8f9fa; border-color: #ccc; color: #000; }
        button.active { background: var(--primary); color: #fff; border-color: var(--primary); }

        input[type=range] { width: 100%; height: 4px; accent-color: var(--primary); cursor: pointer; }
        .row { display: flex; justify-content: space-between; align-items: center; font-size: 11px; color: #666; gap: 10px; }
        .label { font-weight: 600; color: #444; }

        /* 상단 툴바 (스크롤 가능) */
        #top-bar { 
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%); 
            display: flex; gap: 6px; padding: 8px; background: var(--bg-light);
            border-radius: 18px; backdrop-filter: blur(12px); z-index: 100;
            box-shadow: var(--shadow); border: 1px solid rgba(255,255,255,0.5);
            max-width: 95vw; overflow-x: auto; -webkit-overflow-scrolling: touch;
        }
        #top-bar::-webkit-scrollbar { display: none; }

        /* 모바일 이동 패드 */
        #mobile-dpad {
            display: none; position: absolute; left: 20px; bottom: 20px;
            width: 140px; height: 140px; z-index: 100;
            grid-template-areas: ". up ." "left . right" ". down .";
            gap: 10px;
        }
        .dbtn {
            width: 44px; height: 44px; background: var(--bg-light); border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            border: 1px solid var(--border); box-shadow: var(--shadow);
            font-size: 20px; color: var(--primary); cursor: pointer;
        }
        .dbtn:active { background: var(--primary); color: white; }

        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 6px; height: 6px;
            background: var(--primary); border-radius: 50%; transform: translate(-50%, -50%);
            pointer-events: none; display: none; box-shadow: 0 0 10px rgba(0,122,255,0.5); z-index: 1;
        }
        #toast {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); color: white; padding: 10px 20px; border-radius: 25px;
            opacity: 0; transition: opacity 0.4s; font-size: 13px; pointer-events: none; z-index: 1000;
            text-align: center;
        }
        
        /* 옵션 버튼 위치: 우측 하단 고정 */
        #mobile-menu-btn { 
            display: none; width:44px; height:44px; border-radius:12px; font-size:18px; 
            position: absolute; bottom: 20px; right: 20px; z-index: 101; 
            background: var(--bg-light); border: 1px solid var(--border); box-shadow: var(--shadow);
        }

        #btn-gyro.active { background: #5856D6; border-color: #5856D6; color: white; }
        
        #VRButton {
            position: absolute !important;
            bottom: auto !important;
            top: 20px !important;
            left: 50% !important;
            transform: translateX(-50%) translateY(70px);
            z-index: 1001;
            display: none;
        }

        @media (max-width: 768px) {
            .panel { display: none; }
            #mobile-menu-btn { display: block; }
            #mobile-dpad.active { display: grid; }
            .option-container { flex-direction: column; }
            .upload-box { width: 80vw; padding: 25px; }
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="landing-page">
        <h1 style="margin:0; font-size:32px; font-weight:900; color:#222; letter-spacing:-0.02em;">3D GLB Explorer</h1>
        <div class="option-container">
            <div class="upload-box project-btn" id="btn-load-project">
                <h2>PROJECT MODEL</h2>
                <p>저장소의 model.glb 로드</p>
            </div>
            <div class="upload-box" onclick="document.getElementById('file-input').click()">
                <h2>BROWSE FILES</h2>
                <p>기기에 있는 모델 선택</p>
                <input type="file" id="file-input" accept=".glb,.gltf" style="display:none;">
            </div>
        </div>
    </div>

    <div id="ui-layer" style="display:none;">
        <div id="crosshair"></div>
        <button id="mobile-menu-btn" onclick="toggleMobileSettings()">⚙</button>

        <div id="top-bar">
            <button id="mode-render" class="active">RENDER</button>
            <button id="mode-white">WHITE</button>
            <span style="width:1px; height:16px; background:#ddd; margin:auto 4px; flex-shrink:0;"></span>
            <button id="cam-fly" class="active">FLY</button>
            <button id="cam-walk">WALK</button>
            <button id="cam-iso">ISO</button>
            <span style="width:1px; height:16px; background:#ddd; margin:auto 4px; flex-shrink:0;"></span>
            <button id="btn-reset">RESET</button>
            <button id="btn-gyro">GYRO</button>
            <button id="btn-vr" style="background:#000; color:#fff;">VR VIEW</button>
            <button id="btn-help">GUIDE</button>
            <button id="btn-capture" style="color:var(--primary)">CAPTURE</button>
        </div>

        <div id="mobile-dpad">
            <div class="dbtn" style="grid-area: up;" id="d-up">↑</div>
            <div class="dbtn" style="grid-area: left;" id="d-left">←</div>
            <div class="dbtn" style="grid-area: right;" id="d-right">→</div>
            <div class="dbtn" style="grid-area: down;" id="d-down">↓</div>
        </div>

        <div id="help-panel" class="panel">
            <div class="panel-header">CONTROLS <button id="close-help" style="border:none;background:none;font-size:14px;padding:0">×</button></div>
            <div class="panel-content">
                <div class="help-grid">
                    <div class="help-section">PC / MOUSE</div>
                    <span class="key">W A S D</span><span>이동 (앞뒤좌우)</span>
                    <span class="key">E / Q</span><span>상승 / 하강 (Fly)</span>
                    <span class="key">MOUSE</span><span>시점 회전</span>
                    
                    <div class="help-section">VR (Meta Quest)</div>
                    <span class="key">Left Stick</span><span>부드러운 이동</span>
                    <span class="key">Right Stick</span><span>좌우 시점 회전</span>
                    <span class="key">Right Trigger</span><span>조준점 텔레포트</span>
                    
                    <div class="help-section">Mobile</div>
                    <span class="key">D-Pad</span><span>이동 패드</span>
                    <span class="key">GYRO</span><span>센서 기반 시점 조작</span>
                </div>
            </div>
        </div>

        <div id="env-panel" class="panel">
            <div class="panel-header">LIGHTING & SKY <button class="toggle-btn" style="border:none;background:none;font-size:14px;padding:0">－</button></div>
            <div class="panel-content">
                <div class="row">
                    <span class="label">Sky Type</span>
                    <div style="display:flex; gap:4px; flex:1; margin-left:10px;">
                        <button id="bg-hdri" class="active" style="flex:1;">REAL</button>
                        <button id="bg-color" style="flex:1;">SOLID</button>
                    </div>
                </div>
                <div class="row" id="hdr-load-row">
                    <span class="label">HDR Load</span>
                    <button onclick="document.getElementById('hdr-input').click()" style="flex:1">IMPORT .HDR</button>
                    <input type="file" id="hdr-input" accept=".hdr,.exr" style="display:none;">
                </div>
                <div class="row" id="bg-color-picker-row" style="display:none;">
                    <span class="label">Custom Color</span>
                    <input type="color" id="bg-color-val" value="#ffffff" style="width:40px; height:24px; border:none; padding:0; background:none; cursor:pointer;">
                </div>
                <div class="row">
                    <span class="label">Intensity</span>
                    <input type="range" id="sun-intensity" min="0" max="10" step="0.1" value="3.5">
                </div>
                <div class="row">
                    <span class="label">Angle</span>
                    <input type="range" id="sun-angle" min="0" max="360" value="145">
                </div>
            </div>
        </div>

        <div id="cut-panel" class="panel">
            <div class="panel-header">SECTION ANALYSIS <button class="toggle-btn" style="border:none;background:none;font-size:14px;padding:0">－</button></div>
            <div class="panel-content">
                <div class="row">
                    <span class="label">Active</span>
                    <button id="cut-toggle" class="active" style="width:60px;">ON</button>
                </div>
                <div class="row" style="gap:4px;">
                    <button id="axis-x" class="axis-btn" style="flex:1">X</button>
                    <button id="axis-y" class="axis-btn active" style="flex:1">Y</button>
                    <button id="axis-z" class="axis-btn" style="flex:1">Z</button>
                    <button id="axis-flip" style="color:var(--primary)">FLIP</button>
                </div>
                <div class="row">
                    <span class="label">Offset</span>
                    <input type="range" id="cut-slider" min="-100" max="100" value="100">
                </div>
                <div class="row">
                    <span class="label">Cut Color</span>
                    <input type="color" id="cut-color" value="#007AFF" style="width:40px; height:24px; border:none; padding:0; background:none; cursor:pointer;"> 
                </div>
            </div>
        </div>

        <div id="toast">Message</div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { VRButton } from 'three/addons/webxr/VRButton.js';

        let scene, renderer, perspCamera, orthoCamera, activeCamera, pControls, oControls;
        let cameraRig; 
        let model = null, modelGroup = new THREE.Group();
        let originalMaterials = new Map();
        let envTexture, bgColor = new THREE.Color(0xffffff), skyColor = new THREE.Color(0x87CEEB);
        let sunLight, hemiLight, ambientLight;
        
        let initialCamPos = new THREE.Vector3(20, 20, 20);
        let initialCamRot = new THREE.Euler();

        const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
        const clipPlane = new THREE.Plane(new THREE.Vector3(0, -1, 0), 100);
        let clipAxis = 'y', clipNegate = true, cutLineColor = new THREE.Color(0x007AFF);
        const state = { mode: 'render', cam: 'fly', bg: 'sky', cutEnabled: true, gyro: false };

        const velocity = new THREE.Vector3(), direction = new THREE.Vector3(), move = { f:0, b:0, l:0, r:0, u:0, d:0 };
        let speedMult = 1;
        const raycaster = new THREE.Raycaster();

        // VR 컨트롤러 변수
        let controller1, controller2;
        const tempMatrix = new THREE.Matrix4();
        let teleportMarker;

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = skyColor; 
            scene.add(modelGroup);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.localClippingEnabled = true; 
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 1.3;
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            cameraRig = new THREE.Group();
            scene.add(cameraRig);

            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            const roomEnv = new RoomEnvironment();
            envTexture = pmremGenerator.fromScene(roomEnv, 0.04).texture;
            scene.environment = envTexture;

            const aspect = window.innerWidth / window.innerHeight;
            perspCamera = new THREE.PerspectiveCamera(60, aspect, 0.1, 10000);
            perspCamera.position.copy(initialCamPos);
            cameraRig.add(perspCamera); 

            const frustum = 30;
            orthoCamera = new THREE.OrthographicCamera(-frustum*aspect, frustum*aspect, frustum, -frustum, 0.1, 10000);
            orthoCamera.position.set(50, 50, 50);
            orthoCamera.lookAt(0, 0, 0);
            activeCamera = perspCamera;

            ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 1.2);
            scene.add(hemiLight);
            sunLight = new THREE.DirectionalLight(0xffffff, 3.5);
            sunLight.position.set(30, 50, 30);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.set(2048, 2048);
            scene.add(sunLight);

            const vrBtnEl = VRButton.createButton(renderer);
            vrBtnEl.id = "VRButton";
            document.body.appendChild(vrBtnEl);

            controller1 = renderer.xr.getController(0);
            controller1.addEventListener('selectstart', onSelectStart);
            controller1.addEventListener('selectend', onSelectEnd);
            cameraRig.add(controller1);

            controller2 = renderer.xr.getController(1);
            controller2.addEventListener('selectstart', onSelectStart);
            controller2.addEventListener('selectend', onSelectEnd);
            cameraRig.add(controller2);

            const lineGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1)]);
            const line = new THREE.Line(lineGeometry);
            line.name = 'line'; line.scale.z = 5;
            controller1.add(line.clone());
            controller2.add(line.clone());

            teleportMarker = new THREE.Mesh(
                new THREE.RingGeometry(0.2, 0.25, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial({ color: 0x007AFF, transparent: true, opacity: 0.5 })
            );
            teleportMarker.visible = false;
            scene.add(teleportMarker);

            pControls = new PointerLockControls(perspCamera, document.body);
            oControls = new OrbitControls(perspCamera, renderer.domElement);
            oControls.enableDamping = true;
            oControls.screenSpacePanning = true;

            setupEvents();
            setupUI();
            setupMobileDpad();
            makePanelsDraggable();
            
            switchCam('fly');
        }

        function onSelectStart() { this.userData.isSelecting = true; }
        function onSelectEnd() {
            this.userData.isSelecting = false;
            if (teleportMarker.visible) {
                cameraRig.position.set(teleportMarker.position.x, cameraRig.position.y, teleportMarker.position.z);
                teleportMarker.visible = false;
            }
        }

        function loadGLB(url) {
            let finalUrl = url;
            if (!url.startsWith('blob:') && !url.startsWith('http')) {
                try {
                    finalUrl = new URL(url, window.location.href).href;
                } catch (e) {
                    console.warn("URL Normalization failed:", e);
                }
            }

            showToast("모델을 가져오는 중...");
            new GLTFLoader().load(finalUrl, (gltf) => {
                if(model) modelGroup.remove(model);
                model = gltf.scene;
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                model.position.sub(center); 
                model.traverse(c => {
                    if(c.isMesh) {
                        c.castShadow = true; c.receiveShadow = true;
                        originalMaterials.set(c.uuid, c.material);
                        applyClipping(c.material);
                        const edges = new THREE.EdgesGeometry(c.geometry, 25);
                        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ 
                            color: 0x000000, polygonOffset: true, polygonOffsetFactor: -1, polygonOffsetUnits: -1 
                        }));
                        line.material.clippingPlanes = [clipPlane];
                        line.visible = false; line.userData.isEdge = true;
                        c.add(line); 
                    }
                });
                modelGroup.add(model);
                const maxDim = Math.max(size.x, size.y, size.z);
                const slider = document.getElementById('cut-slider');
                slider.min = -maxDim; slider.max = maxDim; slider.value = maxDim;
                updateClipPlane(slider.value);
                document.getElementById('landing-page').style.display = 'none';
                document.getElementById('ui-layer').style.display = 'block';
                oControls.target.set(0, 0, 0);
                initialCamPos.copy(perspCamera.position);
                initialCamRot.copy(perspCamera.rotation);
                showToast("로드 성공");
            }, undefined, (err) => showToast("로드 실패"));
        }

        function applyClipping(m) {
            if(Array.isArray(m)) m.forEach(x => x.clippingPlanes = [clipPlane]);
            else m.clippingPlanes = [clipPlane];
        }

        function updateClipPlane(val) {
            const v = parseFloat(val);
            clipPlane.constant = clipNegate ? v : -v;
            clipPlane.normal.set(0,0,0);
            const dir = clipNegate ? -1 : 1;
            if(clipAxis === 'x') clipPlane.normal.x = dir;
            if(clipAxis === 'y') clipPlane.normal.y = dir;
            if(clipAxis === 'z') clipPlane.normal.z = dir;
        }

        function toggleMode(mode) {
            state.mode = mode;
            const isRender = mode === 'render';
            document.getElementById('mode-render').classList.toggle('active', isRender);
            document.getElementById('mode-white').classList.toggle('active', !isRender);
            if (!isRender) {
                scene.background = new THREE.Color(0xffffff);
                scene.environment = null;
                ambientLight.intensity = 1.8; hemiLight.intensity = 2.0; sunLight.intensity = 2.5;
            } else {
                scene.background = (state.bg === 'sky') ? (envTexture && envTexture.isTexture ? envTexture : skyColor) : bgColor;
                scene.environment = envTexture;
                ambientLight.intensity = 0.8; hemiLight.intensity = 1.2; sunLight.intensity = 3.5;
            }
            if(!model) return;
            const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 1.0, metalness: 0.0, side: THREE.DoubleSide });
            model.traverse(c => {
                if(c.isMesh) {
                    c.material = isRender ? originalMaterials.get(c.uuid) : whiteMat.clone();
                    applyClipping(c.material);
                    c.children.forEach(ch => { if(ch.userData.isEdge) { ch.visible = !isRender; ch.material.color.set(0x000000); } });
                }
            });
        }

        function setupEvents() {
            window.addEventListener('resize', () => {
                const aspect = window.innerWidth/window.innerHeight;
                perspCamera.aspect = aspect; perspCamera.updateProjectionMatrix();
                orthoCamera.left = -30*aspect; orthoCamera.right = 30*aspect; orthoCamera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            document.addEventListener('keydown', e => {
                switch(e.code) {
                    case 'KeyW': move.f = 1; break; case 'KeyS': move.b = 1; break;
                    case 'KeyA': move.l = 1; break; case 'KeyD': move.r = 1; break;
                    case 'KeyE': move.u = 1; break; case 'KeyQ': move.d = 1; break;
                    case 'ShiftLeft': speedMult = 2.5; break;
                    case 'Space': if(state.cam === 'walk' && velocity.y <= 0) velocity.y += 10; break;
                }
            });
            document.addEventListener('keyup', e => {
                switch(e.code) {
                    case 'KeyW': move.f = 0; break; case 'KeyS': move.b = 0; break;
                    case 'KeyA': move.l = 0; break; case 'KeyD': move.r = 0; break;
                    case 'KeyE': move.u = 0; break; case 'KeyQ': move.d = 0; break;
                    case 'ShiftLeft': speedMult = 1; break;
                }
            });
            window.addEventListener('deviceorientation', (e) => {
                if (!state.gyro) return;
                const alpha = e.alpha ? THREE.MathUtils.degToRad(e.alpha) : 0;
                const beta = e.beta ? THREE.MathUtils.degToRad(e.beta) : 0;
                perspCamera.rotation.order = 'YXZ';
                perspCamera.rotation.x = beta - Math.PI / 2;
                perspCamera.rotation.y = alpha;
                perspCamera.rotation.z = 0;
            });

            if(!isMobile) {
                document.addEventListener('click', (e) => {
                    if(e.target.closest('button') || e.target.closest('input') || e.target.closest('.panel')) return;
                    if(state.cam !== 'iso' && !pControls.isLocked && !state.gyro && !document.pointerLockElement) {
                        try {
                            const promise = pControls.lock();
                            if (promise instanceof Promise) promise.catch(() => {});
                        } catch (err) { }
                    }
                });
                document.addEventListener('pointerlockerror', () => {
                    showToast("Camera lock restricted.");
                });
            }
        }

        function setupMobileDpad() {
            const bind = (id, key) => {
                const el = document.getElementById(id);
                if (!el) return;
                el.addEventListener('touchstart', (e) => { e.preventDefault(); move[key] = 1; });
                el.addEventListener('touchend', (e) => { e.preventDefault(); move[key] = 0; });
            };
            bind('d-up', 'f'); bind('d-down', 'b'); bind('d-left', 'l'); bind('d-right', 'r');
        }

        function switchCam(mode) {
            state.cam = mode;
            ['cam-fly','cam-walk','cam-iso'].forEach(id => {
                const btn = document.getElementById(id);
                if (btn) btn.classList.toggle('active', id === `cam-${mode}`);
            });
            const isIso = mode === 'iso';
            document.getElementById('crosshair').style.display = isIso ? 'none' : 'block';
            if(isMobile) document.getElementById('mobile-dpad').classList.toggle('active', !isIso);
            if(isIso) {
                activeCamera = orthoCamera; oControls.object = orthoCamera; oControls.enabled = true;
                disableGyro();
            } else {
                activeCamera = perspCamera; oControls.object = perspCamera; oControls.enabled = isMobile && !state.gyro;
            }
            showToast(`모드: ${mode.toUpperCase()}`);
        }

        function toggleGyro() {
            if (!isMobile) { showToast("모바일 기기 전용입니다."); return; }
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission().then(res => { if (res === 'granted') applyGyroState(); });
            } else { applyGyroState(); }
        }

        function applyGyroState() {
            state.gyro = !state.gyro;
            document.getElementById('btn-gyro').classList.toggle('active', state.gyro);
            if (state.gyro) { oControls.enabled = false; showToast("자이로 활성"); }
            else disableGyro();
        }

        function disableGyro() {
            state.gyro = false;
            if (document.getElementById('btn-gyro')) document.getElementById('btn-gyro').classList.remove('active');
            if (isMobile && state.cam !== 'iso') oControls.enabled = true;
        }

        function setupUI() {
            document.getElementById('btn-load-project').onclick = () => loadGLB('model.glb');
            document.getElementById('file-input').onchange = (e) => { if (e.target.files[0]) loadGLB(URL.createObjectURL(e.target.files[0])); };
            document.getElementById('mode-render').onclick = () => toggleMode('render');
            document.getElementById('mode-white').onclick = () => toggleMode('white');
            document.getElementById('cam-fly').onclick = () => switchCam('fly');
            document.getElementById('cam-walk').onclick = () => switchCam('walk');
            document.getElementById('cam-iso').onclick = () => switchCam('iso');
            document.getElementById('btn-reset').onclick = () => {
                cameraRig.position.set(0,0,0);
                perspCamera.position.copy(initialCamPos); perspCamera.rotation.set(initialCamRot.x, initialCamRot.y, initialCamRot.z);
                oControls.target.set(0, 0, 0); velocity.set(0,0,0); showToast("카메라 리셋");
            };
            document.getElementById('btn-gyro').onclick = () => toggleGyro();
            document.getElementById('btn-vr').onclick = () => {
                const btn = document.getElementById('VRButton');
                if (btn) btn.click();
            };
            document.getElementById('btn-help').onclick = () => document.getElementById('help-panel').style.display = 'flex';
            document.getElementById('close-help').onclick = () => document.getElementById('help-panel').style.display = 'none';
            document.getElementById('btn-capture').onclick = () => {
                renderer.render(scene, activeCamera);
                const link = document.createElement('a'); link.download = 'capture.png'; link.href = renderer.domElement.toDataURL('image/png'); link.click();
            };
            document.getElementById('bg-hdri').onclick = (e) => { 
                state.bg='sky'; if (state.mode === 'render') scene.background = envTexture && envTexture.isTexture ? envTexture : skyColor;
                e.target.classList.add('active'); document.getElementById('bg-color').classList.remove('active');
            };
            document.getElementById('bg-color').onclick = (e) => { 
                state.bg='color'; if (state.mode === 'render') scene.background = bgColor;
                e.target.classList.add('active'); document.getElementById('bg-hdri').classList.remove('active');
            };
            document.getElementById('bg-color-val').oninput = (e) => { bgColor.set(e.target.value); if (state.mode === 'render' && state.bg === 'color') scene.background = bgColor; };
            document.getElementById('sun-intensity').oninput = (e) => sunLight.intensity = parseFloat(e.target.value);
            document.getElementById('sun-angle').oninput = (e) => {
                const rad = e.target.value * (Math.PI/180);
                sunLight.position.x = Math.sin(rad) * 40; sunLight.position.z = Math.cos(rad) * 40;
            };
            document.getElementById('cut-toggle').onclick = (e) => { state.cutEnabled = !state.cutEnabled; renderer.localClippingEnabled = state.cutEnabled; e.target.classList.toggle('active'); };
            const setAxis = (ax) => { clipAxis = ax; ['axis-x', 'axis-y', 'axis-z'].forEach(id => document.getElementById(id).classList.toggle('active', id === `axis-${ax}`)); updateClipPlane(document.getElementById('cut-slider').value); };
            document.getElementById('axis-x').onclick = () => setAxis('x');
            document.getElementById('axis-y').onclick = () => setAxis('y');
            document.getElementById('axis-z').onclick = () => setAxis('z');
            document.getElementById('axis-flip').onclick = () => { clipNegate = !clipNegate; updateClipPlane(document.getElementById('cut-slider').value); };
            document.getElementById('cut-slider').oninput = (e) => updateClipPlane(e.target.value);
        }

        function handleVRInput() {
            const session = renderer.xr.getSession();
            if (!session) return;
            const speed = 0.05;
            const rotationSpeed = 0.03;
            for (const source of session.inputSources) {
                if (!source.gamepad) continue;
                const axes = source.gamepad.axes; 
                if (source.handedness === 'left') {
                    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(perspCamera.quaternion);
                    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(perspCamera.quaternion);
                    forward.y = 0; right.y = 0; forward.normalize(); right.normalize();
                    cameraRig.position.addScaledVector(forward, -axes[1] * speed);
                    cameraRig.position.addScaledVector(right, axes[0] * speed);
                }
                if (source.handedness === 'right') {
                    if (Math.abs(axes[2] || axes[0]) > 0.5) {
                        cameraRig.rotation.y -= Math.sign(axes[2] || axes[0]) * rotationSpeed;
                    }
                }
                if (source.handedness === 'right' && source.gamepad.buttons[0].pressed) {
                    tempMatrix.identity().extractRotation(controller2.matrixWorld);
                    raycaster.ray.origin.setFromMatrixPosition(controller2.matrixWorld);
                    raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
                    const intersects = raycaster.intersectObjects(modelGroup.children, true);
                    if (intersects.length > 0) {
                        teleportMarker.position.copy(intersects[0].point);
                        teleportMarker.visible = true;
                    } else { teleportMarker.visible = false; }
                }
            }
        }

        function makePanelsDraggable() {
            document.querySelectorAll('.panel').forEach(panel => {
                const header = panel.querySelector('.panel-header');
                const toggle = panel.querySelector('.toggle-btn');
                if(toggle) toggle.onclick = (e) => { e.stopPropagation(); panel.classList.toggle('minimized'); toggle.innerText = panel.classList.contains('minimized') ? '＋' : '－'; };
                let isDragging = false, startX, startY, initLeft, initTop;
                header.onmousedown = (e) => { isDragging = true; startX = e.clientX; startY = e.clientY; initLeft = panel.offsetLeft; initTop = panel.offsetTop; document.onmousemove = (e) => { if(!isDragging) return; panel.style.left = (initLeft + e.clientX - startX) + 'px'; panel.style.top = (initTop + e.clientY - startY) + 'px'; }; document.onmouseup = () => { isDragging = false; document.onmousemove = null; }; };
            });
        }

        function animate() {
            renderer.setAnimationLoop(() => {
                if (renderer.xr.isPresenting) {
                    handleVRInput();
                } else {
                    if(oControls.enabled && !state.gyro) oControls.update();
                    if(state.cam==='fly'||state.cam==='walk') {
                        const delta = 0.016;
                        velocity.x -= velocity.x * 10.0 * delta; velocity.z -= velocity.z * 10.0 * delta; velocity.y -= velocity.y * 10.0 * delta;
                        direction.z = Number(move.f) - Number(move.b); direction.x = Number(move.r) - Number(move.l); direction.normalize();
                        const speed = (state.cam === 'walk' ? 40 : 60) * speedMult;
                        if (move.f || move.b || move.l || move.r) { velocity.z -= direction.z * speed * delta; velocity.x -= direction.x * speed * delta; }
                        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(perspCamera.quaternion);
                        const right = new THREE.Vector3(1, 0, 0).applyQuaternion(perspCamera.quaternion);
                        if (state.cam === 'walk') { forward.y = 0; right.y = 0; forward.normalize(); right.normalize(); }
                        perspCamera.position.addScaledVector(forward, -velocity.z * delta); perspCamera.position.addScaledVector(right, -velocity.x * delta);
                        if(state.cam === 'fly') { if(move.u) velocity.y += speed * delta; if(move.d) velocity.y -= speed * delta; perspCamera.position.y += velocity.y * delta; }
                        if(state.cam === 'walk') {
                            velocity.y -= 9.8 * 6.0 * delta;
                            raycaster.set(perspCamera.position, new THREE.Vector3(0, -1, 0));
                            const intersects = raycaster.intersectObjects(modelGroup.children, true);
                            if (intersects.length > 0) { const dist = intersects[0].distance; if (dist < 1.7) { perspCamera.position.y = intersects[0].point.y + 1.7; velocity.y = Math.max(0, velocity.y); } }
                            perspCamera.position.y += velocity.y * delta;
                        }
                        if (isMobile && !state.gyro) { const lookDir = new THREE.Vector3(0, 0, -1).applyQuaternion(perspCamera.quaternion); oControls.target.copy(perspCamera.position).add(lookDir); }
                    }
                }
                renderer.render(scene, activeCamera);
            });
        }

        window.toggleMobileSettings = () => {
            const panels = document.querySelectorAll('.panel');
            const isHidden = panels[0].style.display === 'none' || panels[0].style.display === '';
            panels.forEach(p => p.style.display = isHidden ? 'flex' : 'none');
        };

        function showToast(msg) {
            const t = document.getElementById('toast');
            t.innerText = msg; t.style.opacity = 1;
            setTimeout(() => t.style.opacity = 0, 4000);
        }
    </script>
</body>
</html>
