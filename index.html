<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>KIL ARCHITECTURE WEB STUDIO</title>
    <style>
        :root {
            --brand-color: #AF52DE;
            --bg-glass: rgba(255, 255, 255, 0.78);
            --bg-glass-dark: rgba(255, 255, 255, 0.95);
            --border-light: rgba(0, 0, 0, 0.08);
            --shadow-premium: 0 12px 40px rgba(0, 0, 0, 0.12);
            --font-main: -apple-system, BlinkMacSystemFont, "SF Pro Display", "Segoe UI", Roboto, sans-serif;
        }
        body {
            margin: 0; overflow: hidden; background-color: #f5f5f7;
            font-family: var(--font-main); color: #1d1d1f;
            user-select: none; -webkit-user-select: none; touch-action: none;
            -webkit-font-smoothing: antialiased;
        }
        /* --- 랜딩 페이지 --- */
        #landing-page {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: radial-gradient(circle at center, #ffffff 0%, #f2f2f7 100%);
            z-index: 2000; gap: 40px;
        }
        
        .studio-title { text-align: center; }
        .studio-title h1 {
            margin: 0; font-size: 38px; font-weight: 800; letter-spacing: -0.04em;
            background: linear-gradient(180deg, #1d1d1f 0%, #636366 100%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        .studio-title p { margin-top: 10px; color: var(--brand-color); font-size: 13px; letter-spacing: 0.3em; font-weight: 700; text-transform: uppercase; }
        .option-container { display: flex; gap: 24px; flex-wrap: wrap; justify-content: center; }
        .upload-card {
            background: white; border-radius: 32px; padding: 36px; width: 220px;
            text-align: center; cursor: pointer; transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
            border: 1px solid var(--border-light); box-shadow: 0 4px 15px rgba(0,0,0,0.03);
            position: relative;
        }
        .upload-card:hover { transform: translateY(-8px); box-shadow: var(--shadow-premium); border-color: var(--brand-color); }
        .upload-card:active { transform: scale(0.96); }
        .upload-card svg { width: 40px; height: 40px; margin-bottom: 20px; color: var(--brand-color); }
        .upload-card h3 { margin: 0; font-size: 16px; font-weight: 700; }
        /* --- UI 레이어 --- */
        #ui-layer { display: none; }
        .panel {
            position: absolute; left: 24px; width: 280px;
            background: var(--bg-glass); backdrop-filter: blur(40px) saturate(180%);
            border-radius: 24px; box-shadow: var(--shadow-premium);
            border: 1px solid rgba(255,255,255,0.6);
            display: flex; flex-direction: column; z-index: 100;
        }
        .panel-header {
            padding: 18px 24px; cursor: move; display: flex; justify-content: space-between; align-items: center;
            font-weight: 800; font-size: 11px; text-transform: uppercase; letter-spacing: 0.1em; opacity: 0.6;
        }
        .panel-content { padding: 0 24px 24px 24px; display: flex; flex-direction: column; gap: 18px; }
        .panel.minimized .panel-content { display: none; }
        
        #env-panel { top: 100px; }
        #cut-panel { top: 430px; }
        /* --- 상단 바 --- */
        #top-bar {
            position: absolute; top: 24px; left: 50%; transform: translateX(-50%);
            display: flex; align-items: center; gap: 4px; padding: 6px;
            background: rgba(255, 255, 255, 0.9); backdrop-filter: blur(20px);
            border-radius: 20px; z-index: 1000; box-shadow: var(--shadow-premium);
            border: 1px solid var(--border-light);
            max-width: 95vw; overflow-x: auto;
        }
        button {
            display: inline-flex; align-items: center; gap: 8px;
            background: transparent; border: none; color: #1d1d1f; padding: 10px 14px;
            border-radius: 14px; cursor: pointer; font-size: 12px; font-weight: 700;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1); white-space: nowrap;
        }
        button svg { width: 16px; height: 16px; opacity: 0.8; }
        button:hover { background: rgba(0,0,0,0.05); }
        button:active { transform: scale(0.94); }
        button.active { background: var(--brand-color); color: #fff !important; }
        button.active svg { filter: brightness(0) invert(1); opacity: 1; }
        .divider { width: 1px; height: 16px; background: rgba(0,0,0,0.1); margin: 0 6px; flex-shrink: 0; }
        input[type=range] { -webkit-appearance: none; width: 100%; height: 5px; background: rgba(0,0,0,0.08); border-radius: 3px; outline: none; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 22px; background: white; border: 1.5px solid var(--brand-color); border-radius: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); cursor: pointer; transition: transform 0.1s ease; }
        .row { display: flex; justify-content: space-between; align-items: center; width: 100%; }
        .label { color: #86868b; font-size: 11px; text-transform: uppercase; letter-spacing: 0.08em; font-weight: 800; }
        .btn-group-full { display: flex; flex-direction: column; gap: 10px; width: 100%; }
        .row-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px; }
        #copyright {
            position: absolute; bottom: 12px; width: 100%; text-align: center;
            font-size: 9px; color: rgba(0,0,0,0.15); letter-spacing: 0.1em; font-weight: 700; pointer-events: none;
        }
        #toast {
            position: absolute; bottom: 120px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.85); color: white; padding: 12px 24px; border-radius: 20px;
            opacity: 0; transition: all 0.4s; font-size: 13px; z-index: 4000; text-align: center; pointer-events: none;
        }
        #help-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.3); backdrop-filter: blur(10px);
            display: none; justify-content: center; align-items: center; z-index: 3000;
        }
        .help-content { background: white; width: 380px; padding: 32px; border-radius: 32px; box-shadow: var(--shadow-premium); position: relative; }
        .help-grid { display: grid; grid-template-columns: 110px 1fr; gap: 12px; font-size: 13px; margin-top: 20px; }
        .help-label { font-weight: 800; color: var(--brand-color); }
        .help-section-title { font-weight: 900; grid-column: span 2; margin-top: 15px; border-bottom: 1px solid #eee; padding-bottom: 5px; font-size: 14px; }
        .close-help-btn { position: absolute; top: 20px; right: 20px; cursor: pointer; opacity: 0.5; font-size: 20px; }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 4px; height: 4px;
            background: var(--brand-color); border-radius: 50%; transform: translate(-50%, -50%);
            pointer-events: none; display: none; z-index: 1;
        }
        /* --- VR 버튼 숨김 --- */
        #VRButton { display: none !important; visibility: hidden !important; opacity: 0 !important; }
        @media (max-width: 768px) {
            .panel { display: none; }
            .upload-card { width: 85vw; padding: 30px; }
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="landing-page">
        <div class="studio-title">
            <h1>KIL ARCHITECTURE</h1>
            <p>WEB STUDIO 2026</p>
        </div>
        <div class="option-container">
            <div class="upload-card" id="btn-load-project-init">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                <h3>LOAD PROJECT</h3>
            </div>
            <div class="upload-card" id="btn-trigger-file">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"/><line x1="8" y1="21" x2="16" y2="21"/><line x1="12" y1="17" x2="12" y2="21"/></svg>
                <h3>BROWSE FILES</h3>
            </div>
            <input type="file" id="file-input" accept=".glb,.gltf" style="display:none;">
        </div>
        <div id="loading-status" style="display:none; color:var(--brand-color); font-weight:700; font-size:12px; margin-top: 20px;">PROCESSING...</div>
    </div>
    <div id="ui-layer">
        <div id="crosshair"></div>
        <div id="top-bar">
            <button id="btn-home" style="color: var(--brand-color); background: rgba(175, 82, 222, 0.1);">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>HOME
            </button>
            <div class="divider"></div>
            <button id="mode-render" class="active"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><circle cx="12" cy="12" r="10"/><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1 4-10z"/><path d="M2 12h20"/></svg>RENDER</button>
            <button id="mode-white"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5"/><path d="M2 12l10 5 10-5"/></svg>WHITE</button>
            <div class="divider"></div>
            <button id="cam-fly" class="active"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M22 2L11 13"/><path d="M22 2l-7 20-4-9-9-4 20-7z"/></svg>FLY</button>
            <button id="cam-walk"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><circle cx="12" cy="5" r="3"/><path d="M9 22v-5h6v5"/><path d="M12 8v9"/><path d="M7 11l5-3 5 3"/></svg>WALK</button>
            <button id="cam-iso"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M12 3l10 5-10 5-10-5z"/><path d="M2 13l10 5 10-5"/><path d="M2 8l10 5 10-5"/></svg>ISO</button>
            <div class="divider"></div>
            <button id="btn-reset"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>RESET</button>
            <button id="btn-vr" style="background:#1d1d1f; color:#fff;"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><rect x="2" y="6" width="20" height="12" rx="2"/><path d="M12 12h.01"/></svg>VR</button>
            <button id="btn-help"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>GUIDE</button>
            <button id="btn-capture" style="color:var(--brand-color)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg>CAPTURE</button>
        </div>
        <div id="env-panel" class="panel">
            <div class="panel-header">Environment <button class="toggle-btn">－</button></div>
            <div class="panel-content">
                <div class="btn-group-full"><div class="row-grid"><button id="bg-sky" class="active">SKY</button><button id="bg-solid">SOLID</button><button id="bg-hdr">HDR</button></div></div>
                <div id="solid-picker-row" style="display:none;" class="row"><span class="label">COLOR</span><input type="color" id="bg-color-val" value="#ffffff" style="border:none;background:none;width:30px;height:30px;cursor:pointer;"></div>
                <div id="hdr-upload-row" style="display:none;" class="row"><button onclick="document.getElementById('hdr-input').click()" style="width:100%;background:rgba(0,0,0,0.05);justify-content:center;">UPLOAD HDR</button><input type="file" id="hdr-input" accept=".hdr,.exr" style="display:none;"></div>
                <div class="row"><span class="label">LINE WEIGHT</span><input type="range" id="toon-weight" min="0" max="5" step="0.1" value="1.5"></div>
            </div>
        </div>
        <div id="cut-panel" class="panel">
            <div class="panel-header">Section Analysis <button class="toggle-btn">－</button></div>
            <div class="panel-content">
                <div class="row" style="justify-content:center; gap:12px; background:rgba(0,0,0,0.03); padding:10px; border-radius:14px;"><span class="label" style="margin:0;">SECTION</span><button id="cut-toggle" class="active" style="padding:6px 12px; min-width:80px; justify-content:center;">ENABLED</button></div>
                <div class="btn-group-full"><div class="row-grid"><button id="axis-x" class="axis-btn">X-AXIS</button><button id="axis-y" class="axis-btn active">Y-AXIS</button><button id="axis-z" class="axis-btn">Z-AXIS</button></div><button id="axis-flip" style="width:100%; background:rgba(175,82,222,0.1); color:var(--brand-color); justify-content:center; padding:12px; border-radius:14px;"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"><path d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"/></svg> REVERSE</button></div>
                <div class="row"><span class="label">OFFSET</span><input type="range" id="cut-slider" min="-100" max="100" value="100"></div>
            </div>
        </div>
        <div id="copyright">COPYRIGHT BY KIL ARCHITECTURE 2026</div>
        <div id="toast">Message</div>
    </div>
    <!-- 도움말 모달 -->
    <div id="help-modal">
        <div class="help-content">
            <div class="close-help-btn" onclick="toggleGuide(false)">✕</div>
            <h2 style="margin:0; font-size: 20px; font-weight: 800;">Navigation Guide</h2>
            <div class="help-grid">
                <div class="help-section-title">PC 모드 조작</div>
                <div class="help-label">Left Click</div><div>조작 모드 시작 (마우스 고정)</div>
                <div class="help-label">ESC</div><div>조작 해제 (마우스 활성)</div>
                <div class="help-label">W / S / A / D</div><div>이동</div>
                <div class="help-label">E / Q</div><div>수직 상승 / 하강</div>
                <div class="help-label">SHIFT</div><div>2배 속도 이동</div>
                <div class="help-label">CTRL</div><div>4배 속도 이동</div>
                <div class="help-label">Space</div><div>Fly: 지면 착지 / Walk: 점프</div>
                <div class="help-label">Double Click</div><div>텔레포트</div>
            </div>
        </div>
    </div>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        let scene, renderer, perspCamera, orthoCamera, activeCamera, pControls, oControls;
        let cameraRig, model = null, modelGroup = new THREE.Group();
        let originalMaterials = new Map(), envTexture, skyColor = new THREE.Color(0x87CEEB), bgColor = new THREE.Color(0xffffff);
        let sunLight, hemiLight, ambientLight;
        let controller1, controller2, selectedController, intersection, tempMatrix = new THREE.Matrix4();
        let teleportMarker;
        
        const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
        const clipPlane = new THREE.Plane(new THREE.Vector3(0, -1, 0), 100);
        let clipAxis = 'y', clipNegate = true;
        const state = { mode: 'render', cam: 'fly', bg: 'sky', cutEnabled: true };
        const velocity = new THREE.Vector3(), move = { f:0, b:0, l:0, r:0, u:0, d:0 };
        let speedMult = 1, isGrounded = false, raycaster = new THREE.Raycaster();
        let isLockPending = false;
        let modelMaxDim = 50;

        init();
        animate();
        function init() {
            scene = new THREE.Scene(); scene.background = skyColor; scene.add(modelGroup);
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true; renderer.localClippingEnabled = true;
            renderer.toneMapping = THREE.ReinhardToneMapping; renderer.toneMappingExposure = 1.3;
            renderer.xr.enabled = true; document.body.appendChild(renderer.domElement);
            cameraRig = new THREE.Group(); scene.add(cameraRig);
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            envTexture = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
            scene.environment = envTexture;
            
            const aspect = window.innerWidth / window.innerHeight;
            perspCamera = new THREE.PerspectiveCamera(60, aspect, 0.1, 10000);
            perspCamera.position.set(30, 30, 30); cameraRig.add(perspCamera);
            
            orthoCamera = new THREE.OrthographicCamera(-30*aspect, 30*aspect, 30, -30, 0.1, 10000);
            orthoCamera.position.set(50, 50, 50); orthoCamera.lookAt(0, 0, 0);
            
            activeCamera = perspCamera;
            ambientLight = new THREE.AmbientLight(0xffffff, 0.6); scene.add(ambientLight);
            hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 1.0); scene.add(hemiLight);
            sunLight = new THREE.DirectionalLight(0xffffff, 3.0); sunLight.position.set(40, 60, 40); sunLight.castShadow = true;
            scene.add(sunLight);
            const vrBtnEl = VRButton.createButton(renderer); vrBtnEl.id = "VRButton"; document.body.appendChild(vrBtnEl);
            navigator.xr.isSessionSupported('immersive-vr').then(supported => { if (!supported) vrBtnEl.style.display = 'none'; });
            
            pControls = new PointerLockControls(perspCamera, document.body);
            pControls.addEventListener('lock', () => {
                isLockPending = false;
                document.getElementById('crosshair').style.display = 'block';
                oControls.enabled = false;
            });
            pControls.addEventListener('unlock', () => {
                isLockPending = false;
                document.getElementById('crosshair').style.display = 'none';
                if (state.cam === 'iso') oControls.enabled = true;
                else oControls.enabled = false;
            });

            document.addEventListener('pointerlockerror', () => { 
                isLockPending = false; 
                console.warn("Pointer lock error occurred.");
            });

            oControls = new OrbitControls(perspCamera, renderer.domElement);
            oControls.enableDamping = true; oControls.dampingFactor = 0.05; oControls.screenSpacePanning = true;
            oControls.enabled = false;

            teleportMarker = new THREE.Mesh(new THREE.RingGeometry(0.2, 0.25, 32).rotateX(-Math.PI/2), new THREE.MeshBasicMaterial({ color: 0xAF52DE, transparent: true, opacity: 0.8, side: THREE.DoubleSide }));
            teleportMarker.visible = false; scene.add(teleportMarker);
            controller1 = renderer.xr.getController(0); scene.add(controller1);
            controller2 = renderer.xr.getController(1); scene.add(controller2);
            const controllerModelFactory = new XRControllerModelFactory();
            const grip1 = renderer.xr.getControllerGrip(0); grip1.add(controllerModelFactory.createControllerModel(grip1)); scene.add(grip1);
            const grip2 = renderer.xr.getControllerGrip(1); grip2.add(controllerModelFactory.createControllerModel(grip2)); scene.add(grip2);
            const rayGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1)]);
            const rayMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.5, transparent: true });
            const rayLine = new THREE.Line(rayGeometry, rayMaterial); rayLine.scale.z = 5;
            controller1.add(rayLine.clone()); controller2.add(rayLine.clone());
            controller1.addEventListener('selectstart', onSelectStart); controller1.addEventListener('selectend', onSelectEnd);
            controller2.addEventListener('selectstart', onSelectStart); controller2.addEventListener('selectend', onSelectEnd);
            setupEvents(); setupUI(); makePanelsDraggable();
            switchCam('fly');
        }

        function onSelectStart(event) { selectedController = event.target; selectedController.userData.selected = true; }
        function onSelectEnd(event) {
            selectedController = event.target;
            selectedController.userData.selected = false;
            if (intersection) cameraRig.position.copy(intersection.point);
            selectedController = null;
        }

        function loadGLB(url) {
            let finalUrl = url;
            if (!url.startsWith('blob:') && !url.startsWith('http')) {
                try {
                    const base = window.location.origin + window.location.pathname;
                    finalUrl = base.substring(0, base.lastIndexOf('/') + 1) + url;
                } catch(e) { }
            }
            document.getElementById('loading-status').style.display = 'block';
            new GLTFLoader().load(finalUrl, onModelLoaded, undefined, (err) => {
                new GLTFLoader().load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/models/gltf/SheenChair.glb', onModelLoaded);
            });
        }

        function updateOrthoCamera(maxDim) {
            const aspect = window.innerWidth / window.innerHeight;
            const size = maxDim * 0.8; 
            orthoCamera.left = -size * aspect; orthoCamera.right = size * aspect;
            orthoCamera.top = size; orthoCamera.bottom = -size;
            orthoCamera.updateProjectionMatrix();
            orthoCamera.position.set(maxDim, maxDim, maxDim);
            orthoCamera.lookAt(0, 0, 0);
        }

        function onModelLoaded(gltf) {
            document.getElementById('loading-status').style.display = 'none';
            if(model) modelGroup.remove(model); model = gltf.scene;
            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            modelMaxDim = Math.max(size.x, size.y, size.z);
            model.position.sub(center);
            model.traverse(c => {
                if(c.isMesh) {
                    c.castShadow = true; c.receiveShadow = true; originalMaterials.set(c.uuid, c.material); applyClipping(c.material);
                    const line = new THREE.LineSegments(new THREE.EdgesGeometry(c.geometry, 35),
                        new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, opacity: 1.0, polygonOffset: true, polygonOffsetFactor: -2, polygonOffsetUnits: -2 }));
                    line.material.clippingPlanes = [clipPlane]; line.visible = false; line.userData.isEdge = true; c.add(line);
                }
            });
            modelGroup.add(model);
            const slider = document.getElementById('cut-slider'); 
            slider.min = -modelMaxDim; slider.max = modelMaxDim; slider.value = modelMaxDim;
            updateClipPlane(slider.value);
            updateOrthoCamera(modelMaxDim);
            document.getElementById('landing-page').style.display = 'none'; document.getElementById('ui-layer').style.display = 'block';
            oControls.target.set(0,0,0); 
            perspCamera.position.set(modelMaxDim, modelMaxDim, modelMaxDim); 
            oControls.update();
            showToast("Workspace Active");
        }

        function applyClipping(m) { if(Array.isArray(m)) m.forEach(x => x.clippingPlanes = [clipPlane]); else m.clippingPlanes = [clipPlane]; }
        function updateClipPlane(val) { const v = parseFloat(val); clipPlane.constant = clipNegate ? v : -v; clipPlane.normal.set(0,0,0); if(clipAxis==='x') clipPlane.normal.x=clipNegate?-1:1; if(clipAxis==='y') clipPlane.normal.y=clipNegate?-1:1; if(clipAxis==='z') clipPlane.normal.z=clipNegate?-1:1; }
        
        function switchCam(mode) {
            state.cam = mode;
            ['cam-fly','cam-walk','cam-iso'].forEach(id => document.getElementById(id).classList.toggle('active', id === `cam-${mode}`));
            velocity.set(0,0,0);
            if(mode === 'iso') { 
                activeCamera = orthoCamera; oControls.object = orthoCamera; oControls.enabled = true;
                if (pControls.isLocked) pControls.unlock();
                updateOrthoCamera(modelMaxDim);
            } else { 
                activeCamera = perspCamera; oControls.object = perspCamera; oControls.enabled = false;
                if (pControls.isLocked) pControls.unlock();
            }
            oControls.update();
            showToast(`Navigation: ${mode.toUpperCase()}`);
        }

        function setupEvents() {
            window.addEventListener('resize', () => { 
                const aspect = window.innerWidth / window.innerHeight;
                renderer.setSize(window.innerWidth, window.innerHeight); 
                perspCamera.aspect = aspect; perspCamera.updateProjectionMatrix(); 
                if(state.cam === 'iso') updateOrthoCamera(modelMaxDim);
            });
            
            document.addEventListener('mousedown', (e) => {
                if (document.getElementById('landing-page').style.display !== 'none') return;
                if (e.target.closest('button') || e.target.closest('.panel') || e.target.closest('input') || e.target.closest('.help-content')) return;
                if (state.cam !== 'iso' && !pControls.isLocked && !isLockPending && !document.pointerLockElement) {
                    isLockPending = true;
                    try { 
                        const promise = pControls.lock();
                        if (promise && promise.catch) {
                            promise.catch(() => { isLockPending = false; });
                        }
                    } catch(err) { isLockPending = false; }
                }
            });

            window.addEventListener('dblclick', (e) => {
                if (!model || state.cam === 'iso') return;
                const mouse = new THREE.Vector2((e.clientX/window.innerWidth)*2-1, -(e.clientY/window.innerHeight)*2+1);
                raycaster.setFromCamera(mouse, activeCamera);
                const hits = raycaster.intersectObjects(modelGroup.children, true);
                if (hits.length > 0) {
                    const target = hits[0].point;
                    const offset = state.cam === 'walk' ? 1.7 : 0;
                    smoothMove(perspCamera.position, {x:target.x, y:target.y+offset, z:target.z}, 600);
                    smoothMove(oControls.target, target, 600);
                }
            });

            document.addEventListener('keydown', e => {
                if (e.ctrlKey && (e.code === 'KeyS' || e.code === 'KeyD')) e.preventDefault();
                switch(e.code) {
                    case 'KeyW': case 'ArrowUp': move.f = 1; break;
                    case 'KeyS': case 'ArrowDown': move.b = 1; break;
                    case 'KeyA': case 'ArrowLeft': move.l = 1; break;
                    case 'KeyD': case 'ArrowRight': move.r = 1; break;
                    case 'KeyE': move.u = 1; break;
                    case 'KeyQ': move.d = 1; break;
                    case 'ShiftLeft': case 'ShiftRight': speedMult = 2; break;
                    case 'ControlLeft': case 'ControlRight': speedMult = 4; break;
                    case 'Space':
                        if(state.cam === 'fly') {
                            raycaster.set(perspCamera.position, new THREE.Vector3(0, -1, 0));
                            const hits = raycaster.intersectObjects(modelGroup.children, true);
                            if(hits.length > 0) smoothMove(perspCamera.position, {x:hits[0].point.x, y:hits[0].point.y+1.7, z:hits[0].point.z}, 500);
                            switchCam('walk');
                        } else if(state.cam === 'walk' && isGrounded) velocity.y = 6;
                        break;
                }
            });
            document.addEventListener('keyup', e => { 
                switch(e.code) { 
                    case 'KeyW': case 'ArrowUp': move.f = 0; break; case 'KeyS': case 'ArrowDown': move.b = 0; break; 
                    case 'KeyA': case 'ArrowLeft': move.l = 0; break; case 'KeyD': case 'ArrowRight': move.r = 0; break; 
                    case 'KeyE': move.u = 0; break; case 'KeyQ': move.d = 0; break; 
                    case 'ShiftLeft': case 'ShiftRight': case 'ControlLeft': case 'ControlRight': speedMult = 1; break; 
                } 
            });
        }

        function smoothMove(obj, target, duration) {
            const start = obj.clone(); const startTime = performance.now();
            function step(now) { const t = Math.min((now - startTime) / duration, 1); const ease = t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t; obj.lerpVectors(start, new THREE.Vector3(target.x, target.y, target.z), ease); if (t < 1) requestAnimationFrame(step); else oControls.update(); }
            requestAnimationFrame(step);
        }

        function setupUI() {
            const bindClick = (id, fn) => { const el = document.getElementById(id); if(el) el.onclick = fn; };
            const bindInput = (id, fn) => { const el = document.getElementById(id); if(el) el.oninput = fn; };
            bindClick('btn-load-project-init', () => loadGLB('model.glb'));
            bindClick('btn-trigger-file', () => document.getElementById('file-input').click());
            document.getElementById('file-input').onchange = (e) => { if(e.target.files[0]) loadGLB(URL.createObjectURL(e.target.files[0])); };
            bindClick('btn-home', () => location.reload());
            bindClick('mode-render', () => toggleMode('render')); bindClick('mode-white', () => toggleMode('white'));
            bindClick('cam-fly', () => switchCam('fly')); bindClick('cam-walk', () => switchCam('walk')); bindClick('cam-iso', () => switchCam('iso'));
            
            bindClick('btn-reset', () => { 
                oControls.target.set(0,0,0); perspCamera.position.set(modelMaxDim, modelMaxDim, modelMaxDim); 
                if(state.cam === 'iso') updateOrthoCamera(modelMaxDim);
                oControls.update(); showToast("View Reset");
            });
            
            bindClick('btn-vr', () => document.getElementById('VRButton').click());
            bindClick('btn-help', () => toggleGuide(true));
            bindClick('btn-capture', () => { renderer.render(scene, activeCamera); const link = document.createElement('a'); link.download = 'capture.png'; link.href = renderer.domElement.toDataURL('image/png'); link.click(); });
            bindClick('bg-sky', () => setBG('sky')); bindClick('bg-solid', () => setBG('solid')); bindClick('bg-hdr', () => setBG('hdr'));
            bindInput('bg-color-val', (e) => { bgColor.set(e.target.value); if(state.bg==='solid') scene.background=bgColor; });
            document.getElementById('hdr-input').onchange = (e) => { if(e.target.files[0]) new RGBELoader().load(URL.createObjectURL(e.target.files[0]), (tex) => { tex.mapping = THREE.EquirectangularReflectionMapping; envTexture = tex; if(state.bg==='hdr') { scene.background=tex; scene.environment=tex; } }); };
            bindInput('toon-weight', (e) => { if(model) model.traverse(c => { if(c.userData.isEdge) { c.visible = parseFloat(e.target.value) > 0; c.material.opacity = Math.min(parseFloat(e.target.value)/2, 1); } }); });
            bindClick('cut-toggle', (e) => { state.cutEnabled = !state.cutEnabled; renderer.localClippingEnabled = state.cutEnabled; e.target.classList.toggle('active'); });
            const setAxis = (ax) => { clipAxis = ax; ['axis-x','axis-y','axis-z'].forEach(id => document.getElementById(id).classList.toggle('active', id === `axis-${ax}`)); updateClipPlane(document.getElementById('cut-slider').value); };
            bindClick('axis-x', () => setAxis('x')); bindClick('axis-y', () => setAxis('y')); bindClick('axis-z', () => setAxis('z')); bindClick('axis-flip', () => { clipNegate = !clipNegate; updateClipPlane(document.getElementById('cut-slider').value); });
            bindInput('cut-slider', (e) => updateClipPlane(e.target.value));
        }

        function setBG(type) { state.bg = type; ['bg-sky','bg-solid','bg-hdr'].forEach(id => document.getElementById(id).classList.toggle('active', id === `bg-${type}`)); document.getElementById('solid-picker-row').style.display = type==='solid'?'flex':'none'; document.getElementById('hdr-upload-row').style.display = type==='hdr'?'flex':'none'; if(type==='sky'){scene.background=skyColor; scene.environment=envTexture;} else if(type==='solid'){scene.background=bgColor; scene.environment=null;} else {scene.background=envTexture; scene.environment=envTexture;} }
        function toggleMode(mode) {
            state.mode = mode; const isR = mode === 'render';
            document.getElementById('mode-render').classList.toggle('active', isR); document.getElementById('mode-white').classList.toggle('active', !isR);
            if(!isR) { scene.background = new THREE.Color(0xffffff); scene.environment = null; ambientLight.intensity = 2.0; hemiLight.intensity = 2.0; }
            else { setBG(state.bg); ambientLight.intensity = 0.6; hemiLight.intensity = 1.0; }
            const whiteMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
            if(model) model.traverse(c => { if(c.isMesh) { c.material = isR ? originalMaterials.get(c.uuid) : whiteMat.clone(); applyClipping(c.material); c.children.forEach(ch => { if(ch.userData.isEdge) ch.visible = !isR && document.getElementById('toon-weight').value > 0; }); } });
        }

        function makePanelsDraggable() {
            document.querySelectorAll('.panel').forEach(p => {
                const h = p.querySelector('.panel-header'); const t = p.querySelector('.toggle-btn');
                t.onclick = (e) => { e.stopPropagation(); p.classList.toggle('minimized'); t.innerText = p.classList.contains('minimized')?'＋':'－'; };
                let isD = false, sx, sy, il, it;
                h.onmousedown = (e) => { isD = true; sx = e.clientX; sy = e.clientY; il = p.offsetLeft; it = p.offsetTop;
                    document.onmousemove = (e) => { if(!isD) return; p.style.left = (il + e.clientX - sx) + 'px'; p.style.top = (it + e.clientY - sy) + 'px'; };
                    document.onmouseup = () => { isD = false; document.onmousemove = null; };
                };
            });
        }

        function animate() {
            renderer.setAnimationLoop(() => {
                const isPresenting = renderer.xr.isPresenting;
                document.getElementById('ui-layer').style.display = isPresenting ? 'none' : 'block';
                if (!isPresenting) {
                    if (state.cam === 'iso') {
                        if (oControls.enabled) oControls.update();
                    } else if (pControls.isLocked) {
                        const delta = 0.016;
                        const baseSpeed = (state.cam === 'walk' ? 15.0 : 25.0); 
                        const speed = baseSpeed * speedMult;
                        const lookDir = new THREE.Vector3(); perspCamera.getWorldDirection(lookDir);
                        const forward = lookDir.clone(); if(state.cam==='walk') forward.y = 0; forward.normalize();
                        const right = new THREE.Vector3().crossVectors(forward, perspCamera.up).normalize();
                        const moveVec = new THREE.Vector3();
                        const mF = (move.f ? 1 : 0) - (move.b ? 1 : 0);
                        const mR = (move.r ? 1 : 0) - (move.l ? 1 : 0);
                        if(mF !== 0) moveVec.addScaledVector(forward, mF * speed * delta);
                        if(mR !== 0) moveVec.addScaledVector(right, mR * speed * delta);

                        const oldPos = perspCamera.position.clone();

                        if (state.cam === 'fly') {
                            if(move.u) moveVec.y += speed * delta;
                            if(move.d) moveVec.y -= speed * delta;
                            perspCamera.position.add(moveVec);
                        } else {
                            perspCamera.position.x += moveVec.x;
                            perspCamera.position.z += moveVec.z;
                            const rayOrigin = new THREE.Vector3(perspCamera.position.x, oldPos.y + 1.0, perspCamera.position.z);
                            raycaster.set(rayOrigin, new THREE.Vector3(0, -1, 0));
                            const hits = raycaster.intersectObjects(modelGroup.children, true);
                            if (hits.length > 0) {
                                const groundY = hits[0].point.y;
                                const targetEyeY = groundY + 1.7;
                                if (Math.abs(targetEyeY - oldPos.y) < 0.5) {
                                    perspCamera.position.y = targetEyeY;
                                    isGrounded = true;
                                } else {
                                    perspCamera.position.copy(oldPos);
                                    isGrounded = true;
                                }
                            } else {
                                perspCamera.position.copy(oldPos);
                                isGrounded = false;
                            }
                        }
                        oControls.target.copy(perspCamera.position).add(perspCamera.getWorldDirection(new THREE.Vector3()).multiplyScalar(5));
                    }
                }
                renderer.render(scene, activeCamera);
            });
        }
        function toggleGuide(s) { document.getElementById('help-modal').style.display = s ? 'flex' : 'none'; }
        function showToast(m) { const t = document.getElementById('toast'); t.innerText = m; t.style.opacity = 1; setTimeout(()=>t.style.opacity = 0, 3000); }
        window.toggleGuide = toggleGuide;
    </script>
</body>
</html>
