<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>KIL ARCHITECTURE WEB STUDIO</title>
    <style>
        :root {
            --brand-color: #AF52DE;
            --bg-glass: rgba(255, 255, 255, 0.82);
            --bg-glass-dark: rgba(0, 0, 0, 0.8);
            --border-light: rgba(0, 0, 0, 0.06);
            --shadow-premium: 0 8px 32px rgba(0, 0, 0, 0.12);
            --font-main: -apple-system, BlinkMacSystemFont, "SF Pro Display", "Segoe UI", Roboto, sans-serif;
        }
        body {
            margin: 0; overflow: hidden; background-color: #f2f2f7;
            font-family: var(--font-main); color: #1d1d1f;
            user-select: none; -webkit-user-select: none;
            -webkit-font-smoothing: antialiased;
            touch-action: none;
        }
        /* Landing Page */
        #landing-page {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: radial-gradient(circle at center, #ffffff 0%, #f2f2f7 100%);
            z-index: 2000; gap: 40px; transition: opacity 0.3s ease;
        }
        .studio-title { text-align: center; }
        .studio-title h1 {
            margin: 0; font-size: 38px; font-weight: 800; letter-spacing: -0.04em;
            background: linear-gradient(180deg, #1d1d1f 0%, #636366 100%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        .studio-title p { margin-top: 10px; color: var(--brand-color); font-size: 13px; letter-spacing: 0.3em; font-weight: 700; text-transform: uppercase; }
        
        .option-container { display: flex; gap: 24px; flex-wrap: wrap; justify-content: center; }
        .upload-card {
            background: white; border-radius: 32px; padding: 36px; width: 220px;
            text-align: center; cursor: pointer; transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
            border: 1px solid var(--border-light); box-shadow: 0 4px 15px rgba(0,0,0,0.03);
            position: relative;
        }
        .upload-card:hover { transform: translateY(-5px); box-shadow: var(--shadow-premium); border-color: var(--brand-color); }
        .upload-card svg { width: 40px; height: 40px; margin-bottom: 20px; color: var(--brand-color); }
        .upload-card h3 { margin: 0; font-size: 16px; font-weight: 700; }
        
        #loading-status { display: none; color: var(--brand-color); font-weight: 700; font-size: 14px; margin-top: 20px; }

        /* UI Layer */
        #ui-layer { display: none; }
        
        /* Top Bar */
        #top-bar {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            display: flex; align-items: center; gap: 4px; padding: 5px;
            background: rgba(255, 255, 255, 0.9); backdrop-filter: blur(20px);
            border-radius: 18px; z-index: 1000; box-shadow: var(--shadow-premium);
            border: 1px solid var(--border-light);
            max-width: 95vw; overflow-x: auto;
        }
        button {
            display: inline-flex; align-items: center; gap: 6px;
            background: transparent; border: none; color: #1d1d1f; padding: 8px 14px;
            border-radius: 12px; cursor: pointer; font-size: 11px; font-weight: 700;
            transition: all 0.2s ease; white-space: nowrap;
        }
        button:hover { background: rgba(0,0,0,0.05); }
        button.active { background: var(--brand-color); color: #fff !important; }
        button svg { width: 14px; height: 14px; opacity: 0.8; }
        button.active svg { filter: brightness(0) invert(1); opacity: 1; }
        .divider { width: 1px; height: 14px; background: rgba(0,0,0,0.1); margin: 0 4px; flex-shrink: 0; }

        /* Mobile Controls */
        #gyro-toggle-btn {
            position: absolute; bottom: 30px; right: 30px;
            width: 56px; height: 56px; border-radius: 28px;
            background: var(--bg-glass-dark); color: white;
            display: none; justify-content: center; align-items: center;
            box-shadow: var(--shadow-premium); z-index: 1100;
            border: 1px solid rgba(255,255,255,0.2); transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #gyro-toggle-btn.active { background: var(--brand-color); transform: scale(1.1); }
        #gyro-toggle-btn svg { width: 24px; height: 24px; }

        #joystick-wrapper {
            position: absolute; bottom: 40px; left: 40px;
            width: 120px; height: 120px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 50%; border: 2px solid rgba(255,255,255,0.3);
            display: none; justify-content: center; align-items: center;
            z-index: 1100; touch-action: none;
        }
        #joystick-knob {
            width: 50px; height: 50px; background: white;
            border-radius: 50%; box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            pointer-events: none;
        }

        /* Side Panels */
        #sidebar-left {
            position: absolute; top: 90px; left: 20px;
            display: flex; flex-direction: column; gap: 14px;
            z-index: 100; pointer-events: none;
        }
        .panel {
            width: 230px; pointer-events: auto;
            background: var(--bg-glass); backdrop-filter: blur(30px) saturate(180%);
            border-radius: 20px; box-shadow: var(--shadow-premium);
            border: 1px solid rgba(255,255,255,0.7);
            display: flex; flex-direction: column; overflow: hidden;
            transition: transform 0.2s ease;
        }
        .panel-header {
            padding: 12px 16px; cursor: move; display: flex; justify-content: space-between; align-items: center;
            font-weight: 800; font-size: 10px; text-transform: uppercase; letter-spacing: 0.05em; color: #86868b;
            background: rgba(0,0,0,0.03); border-bottom: 1px solid var(--border-light);
        }
        .panel-content { padding: 16px; display: flex; flex-direction: column; gap: 14px; }
        .panel.minimized .panel-content { display: none; }
        .toggle-btn { padding: 0; border:none; background:none; cursor: pointer; font-size: 14px; opacity: 0.5; color: #1d1d1f; }

        .row { display: flex; justify-content: space-between; align-items: center; width: 100%; gap: 10px; }
        .label { color: #86868b; font-size: 9px; font-weight: 800; text-transform: uppercase; white-space: nowrap; }
        .btn-group-full { display: flex; flex-direction: column; gap: 8px; width: 100%; }
        .row-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px; width: 100%; }
        .grid-btn { background: rgba(0,0,0,0.05); padding: 8px; font-size: 10px; border-radius: 8px; text-align: center; border: none; cursor: pointer; }
        .grid-btn.active { background: var(--brand-color); color: #fff; }
        input[type=range] { -webkit-appearance: none; width: 100%; height: 4px; background: rgba(0,0,0,0.08); border-radius: 2px; outline: none; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; background: white; border: 1.5px solid var(--brand-color); border-radius: 50%; box-shadow: 0 2px 6px rgba(0,0,0,0.15); cursor: pointer; }

        #ai-response { font-size: 11px; line-height: 1.5; color: #444; background: rgba(0,0,0,0.05); padding: 12px; border-radius: 12px; max-height: 140px; overflow-y: auto; white-space: pre-wrap; }
        #copyright { position: absolute; bottom: 10px; width: 100%; text-align: center; font-size: 8px; color: rgba(0,0,0,0.3); pointer-events: none; }
        #toast { position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.85); color: white; padding: 10px 22px; border-radius: 18px; opacity: 0; transition: opacity 0.4s; font-size: 12px; z-index: 4000; pointer-events: none; backdrop-filter: blur(10px); }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 4px; height: 4px; background: var(--brand-color); border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; display: none; z-index: 1; }
        #VRButton { display: none !important; }

        @media (max-width: 768px) {
            #sidebar-left { display: none; }
            .upload-card { width: 80vw; padding: 24px; }
            #top-bar { top: 10px; }
            #gyro-toggle-btn { display: flex; }
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="landing-page">
        <div class="studio-title">
            <h1>KIL ARCHITECTURE</h1>
            <p>WEB STUDIO 2026</p>
        </div>
        <div class="option-container">
            <div class="upload-card" id="btn-load-sample">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                <h3>LOAD SAMPLE</h3>
            </div>
            <div class="upload-card" id="btn-trigger-file">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"/><line x1="8" y1="21" x2="16" y2="21"/><line x1="12" y1="17" x2="12" y2="21"/></svg>
                <h3>BROWSE FILES</h3>
            </div>
            <input type="file" id="file-input" accept=".glb,.gltf" style="display:none;">
        </div>
        <div id="loading-status">INITIALIZING SCENE...</div>
    </div>
    
    <div id="ui-layer">
        <div id="crosshair"></div>
        <div id="top-bar">
            <button id="btn-home" style="color: var(--brand-color); background: rgba(175, 82, 222, 0.1);">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>HOME
            </button>
            <div class="divider"></div>
            <button id="mode-render" class="active"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><circle cx="12" cy="12" r="10"/><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1 4-10z"/><path d="M2 12h20"/></svg>RENDER</button>
            <button id="mode-white"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5"/><path d="M2 12l10 5 10-5"/></svg>WHITE</button>
            <div class="divider"></div>
            <button id="cam-fly" class="active"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M22 2L11 13"/><path d="M22 2l-7 20-4-9-9-4 20-7z"/></svg>FLY</button>
            <button id="cam-walk"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><circle cx="12" cy="5" r="3"/><path d="M9 22v-5h6v5"/><path d="M12 8v9"/><path d="M7 11l5-3 5 3"/></svg>WALK</button>
            <button id="cam-iso"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M12 3l10 5-10 5-10-5z"/><path d="M2 13l10 5 10-5"/><path d="M2 8l10 5 10-5"/></svg>ISO</button>
            <div class="divider"></div>
            <button id="btn-reset"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>RESET</button>
            <button id="btn-vr" style="background:#1d1d1f; color:#fff;"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><rect x="2" y="6" width="20" height="12" rx="2"/><path d="M12 12h.01"/></svg>VR MODE</button>
            <button id="btn-capture" style="color:var(--brand-color)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg>CAPTURE</button>
        </div>

        <!-- Mobile Specific Controls -->
        <button id="gyro-toggle-btn" title="Gyro Toggle">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>
        </button>

        <div id="joystick-wrapper">
            <div id="joystick-knob"></div>
        </div>
        
        <div id="sidebar-left">
            <!-- Environment Panel -->
            <div id="env-panel" class="panel">
                <div class="panel-header">Environment <button class="toggle-btn" onclick="this.closest('.panel').classList.toggle('minimized')">－</button></div>
                <div class="panel-content">
                    <div class="btn-group-full">
                        <div class="row-grid">
                            <button id="bg-sky" class="grid-btn active">SKY</button>
                            <button id="bg-solid" class="grid-btn">SOLID</button>
                            <button id="bg-hdr" class="grid-btn">HDR</button>
                        </div>
                    </div>
                    <div id="solid-picker-row" style="display:none;" class="row">
                        <span class="label">PICKER</span>
                        <input type="color" id="bg-color-val" value="#ffffff" style="border:none; background:none; width:30px; height:30px; cursor:pointer;">
                    </div>
                    <div id="hdr-upload-row" style="display:none;" class="row">
                        <button id="btn-upload-hdr-manual" style="width:100%; background:rgba(0,0,0,0.05); padding:8px; font-size:10px; border-radius:8px;">UPLOAD HDR</button>
                        <input type="file" id="hdr-input" accept=".hdr,.exr" style="display:none;">
                    </div>
                    <div class="row">
                        <span class="label">OUTLINE</span>
                        <input type="range" id="toon-weight" min="0" max="5" step="0.1" value="1.5">
                    </div>
                </div>
            </div>
            
            <div id="cut-panel" class="panel">
                <div class="panel-header">Section Analysis <button class="toggle-btn" onclick="this.closest('.panel').classList.toggle('minimized')">－</button></div>
                <div class="panel-content">
                    <div class="row">
                        <span class="label">STATUS</span>
                        <button id="cut-toggle" class="active" style="background: var(--brand-color); color:#fff; padding:6px 12px; border-radius:10px; font-size:10px; min-width:60px;">ON</button>
                    </div>
                    <div class="btn-group-full">
                        <div class="row-grid">
                            <button id="axis-x" class="grid-btn axis-btn">X</button>
                            <button id="axis-y" class="grid-btn axis-btn active">Y</button>
                            <button id="axis-z" class="grid-btn axis-btn">Z</button>
                        </div>
                        <button id="axis-flip" style="width:100%; background:rgba(175,82,222,0.1); color:var(--brand-color); padding:10px; border-radius:12px; font-size:10px; font-weight:800;">REVERSE AXIS</button>
                    </div>
                    <div class="row" style="flex-direction: column; align-items: flex-start; gap: 8px;">
                        <span class="label">OFFSET POSITION</span>
                        <input type="range" id="cut-slider" min="-100" max="100" value="100">
                    </div>
                </div>
            </div>

            <div id="ai-panel" class="panel">
                <div class="panel-header">✨ AI Insights <button class="toggle-btn" onclick="this.closest('.panel').classList.toggle('minimized')">－</button></div>
                <div class="panel-content">
                    <div id="ai-response">공간 분석을 시작하려면 아래 버튼을 누르세요.</div>
                    <button id="btn-ai-analyze" style="background: var(--brand-color); color: white; padding: 12px; border-radius: 12px; font-size:11px; font-weight:800; cursor:pointer; box-shadow: 0 4px 12px rgba(175, 82, 222, 0.3);">
                        ✨ ANALYZE VIEW
                    </button>
                </div>
            </div>
        </div>

        <div id="copyright">COPYRIGHT BY KIL ARCHITECTURE 2026</div>
        <div id="toast">Message</div>
    </div>
    
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        
        let scene, renderer, perspCamera, orthoCamera, activeCamera, pControls, oControls;
        let model = null, modelGroup = new THREE.Group();
        let originalMaterials = new Map(), envTexture, skyColor = new THREE.Color(0x87CEEB), bgColor = new THREE.Color(0xffffff);
        let sunLight, hemiLight, ambientLight;
        let isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
        const clipPlane = new THREE.Plane(new THREE.Vector3(0, -1, 0), 100);
        let clipAxis = 'y', clipNegate = true;
        const state = { mode: 'render', cam: 'fly', bg: 'sky', cutEnabled: true };
        const move = { f:0, b:0, l:0, r:0, u:0, d:0 };
        const velocity = new THREE.Vector3();
        let speedMult = 1, isGrounded = false, raycaster = new THREE.Raycaster();
        let modelMaxDim = 50;
        const apiKey = "";
        
        let controllerR, vrRay, teleportTarget;
        const cameraRig = new THREE.Group();
        const GITHUB_SAMPLE_URL = './model.glb';

        // Gyro & Joystick
        let isGyroActive = false;
        let deviceRotation = { alpha: 0, beta: 0, gamma: 0 };
        let screenOrientation = window.orientation || 0;
        const sensorQuaternion = new THREE.Quaternion();
        const constantRotation = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI / 2);

        // Joystick Logic
        const joystick = { active: false, start: { x: 0, y: 0 }, current: { x: 0, y: 0 }, vector: { x: 0, y: 0 } };

        init();

        function init() {
            scene = new THREE.Scene();
            scene.background = skyColor;
            scene.add(modelGroup);

            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true, alpha: false });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.localClippingEnabled = true;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            const aspect = window.innerWidth / window.innerHeight;
            perspCamera = new THREE.PerspectiveCamera(60, aspect, 0.1, 20000);
            perspCamera.position.set(50, 50, 50);

            scene.add(cameraRig);
            cameraRig.add(perspCamera);

            orthoCamera = new THREE.OrthographicCamera(-50*aspect, 50*aspect, 50, -50, 0.1, 20000);
            orthoCamera.position.set(100, 100, 100);
            orthoCamera.lookAt(0,0,0);

            activeCamera = perspCamera;

            ambientLight = new THREE.AmbientLight(0xffffff, 1.2);
            scene.add(ambientLight);
            hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
            scene.add(hemiLight);
            sunLight = new THREE.DirectionalLight(0xffffff, 2.5);
            sunLight.position.set(100, 200, 100);
            sunLight.castShadow = true;
            scene.add(sunLight);

            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            envTexture = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
            scene.environment = envTexture;

            oControls = new OrbitControls(perspCamera, renderer.domElement);
            oControls.enableDamping = true;
            oControls.enabled = isMobile;

            pControls = new PointerLockControls(perspCamera, document.body);
            
            pControls.addEventListener('unlock', () => {
                document.getElementById('crosshair').style.display = 'none';
                if (!isMobile) {
                    oControls.enabled = false;
                    const dir = new THREE.Vector3();
                    perspCamera.getWorldDirection(dir);
                    oControls.target.copy(perspCamera.position).addScaledVector(dir, 10);
                    oControls.update();
                }
            });

            pControls.addEventListener('lock', () => {
                if (!isMobile) {
                    document.getElementById('crosshair').style.display = 'block';
                    oControls.enabled = false;
                }
            });

            const vrBtnEl = VRButton.createButton(renderer);
            vrBtnEl.id = "VRButton";
            document.body.appendChild(vrBtnEl);

            controllerR = renderer.xr.getController(0);
            cameraRig.add(controllerR);

            const geometry = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1) ]);
            const material = new THREE.LineBasicMaterial({ color: 0xAF52DE, transparent: true, opacity: 0.5 });
            vrRay = new THREE.Line(geometry, material);
            vrRay.scale.z = 10;
            vrRay.visible = false;
            controllerR.add(vrRay);

            teleportTarget = new THREE.Mesh(
                new THREE.RingGeometry(0.2, 0.25, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial({ color: 0xAF52DE, transparent: true, opacity: 0.8 })
            );
            teleportTarget.visible = false;
            scene.add(teleportTarget);

            setupEvents();
            setupUI();
            setupJoystick();
            makePanelsDraggable();
            switchCam('fly');
            animate();
        }

        function loadGLB(url) {
            const loadingStatus = document.getElementById('loading-status');
            if(loadingStatus) {
                loadingStatus.style.display = 'block';
                loadingStatus.innerText = "모델 불러오는 중...";
            }
            const loader = new GLTFLoader();
            loader.load(url, (gltf) => {
                document.getElementById('landing-page').style.display = 'none';
                document.getElementById('ui-layer').style.display = 'block';
                onModelLoaded(gltf);
            }, (xhr) => {
                if(loadingStatus) loadingStatus.innerText = `진행도: ${(xhr.loaded/xhr.total*100).toFixed(0)}%`;
            }, (err) => {
                showToast("모델 로드 실패.");
                if(loadingStatus) loadingStatus.style.display = 'none';
            });
        }

        function onModelLoaded(gltf) {
            if(model) modelGroup.remove(model);
            model = gltf.scene;
            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            modelMaxDim = Math.max(size.x, size.y, size.z) || 10;
            model.position.sub(center);
            model.traverse(c => {
                if(c.isMesh) {
                    c.castShadow = true; c.receiveShadow = true;
                    originalMaterials.set(c.uuid, c.material);
                    applyClipping(c.material);
                    const edges = new THREE.EdgesGeometry(c.geometry, 35);
                    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.6 }));
                    line.material.clippingPlanes = [clipPlane];
                    line.userData.isEdge = true;
                    line.visible = true;
                    c.add(line);
                }
            });
            modelGroup.add(model);
            const slider = document.getElementById('cut-slider');
            if(slider) {
                slider.min = -modelMaxDim; slider.max = modelMaxDim; slider.value = modelMaxDim;
                updateClipPlane(slider.value);
            }
            const camDist = modelMaxDim * 1.5;
            perspCamera.position.set(camDist, camDist, camDist);
            oControls.target.set(0,0,0);
            oControls.update();
            showToast("Project Loaded Successfully");
        }

        function switchCam(mode) {
            state.cam = mode;
            ['cam-fly','cam-walk','cam-iso'].forEach(id => { 
                const el = document.getElementById(id); 
                if(el) el.classList.toggle('active', id === `cam-${mode}`); 
            });

            // Joystick display
            const joystickUI = document.getElementById('joystick-wrapper');
            if (isMobile && (mode === 'fly' || mode === 'walk')) {
                joystickUI.style.display = 'flex';
            } else {
                joystickUI.style.display = 'none';
            }

            if(mode === 'iso') { 
                const frustumSize = modelMaxDim * 2;
                const aspect = window.innerWidth / window.innerHeight;
                orthoCamera.left = -frustumSize * aspect / 2; orthoCamera.right = frustumSize * aspect / 2;
                orthoCamera.top = frustumSize / 2; orthoCamera.bottom = -frustumSize / 2;
                orthoCamera.position.set(modelMaxDim, modelMaxDim, modelMaxDim);
                orthoCamera.lookAt(0,0,0); orthoCamera.updateProjectionMatrix();
                activeCamera = orthoCamera; oControls.object = orthoCamera; oControls.enabled = true; 
                if(document.pointerLockElement) document.exitPointerLock();
            } else { 
                activeCamera = perspCamera; oControls.object = perspCamera; oControls.enabled = isMobile;
            }
        }

        // Gyro Toggle Logic
        async function toggleGyro() {
            const btn = document.getElementById('gyro-toggle-btn');
            if (isGyroActive) {
                isGyroActive = false;
                btn.classList.remove('active');
                if (isMobile) oControls.enabled = true;
                window.removeEventListener('deviceorientation', onDeviceOrientation);
                showToast("자이로 모드 종료");
            } else {
                if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                    try {
                        const permission = await DeviceOrientationEvent.requestPermission();
                        if (permission === 'granted') {
                            startGyro(btn);
                        } else {
                            showToast("권한이 거부되었습니다.");
                        }
                    } catch (e) { showToast("자이로 요청 오류"); }
                } else {
                    startGyro(btn);
                }
            }
        }

        function startGyro(btn) {
            isGyroActive = true;
            btn.classList.add('active');
            if (isMobile) oControls.enabled = false;
            window.addEventListener('deviceorientation', onDeviceOrientation, true);
            showToast("자이로 모드 시작");
        }

        function onDeviceOrientation(event) {
            deviceRotation.alpha = event.alpha ? THREE.MathUtils.degToRad(event.alpha) : 0;
            deviceRotation.beta = event.beta ? THREE.MathUtils.degToRad(event.beta) : 0;
            deviceRotation.gamma = event.gamma ? THREE.MathUtils.degToRad(event.gamma) : 0;
        }

        function updateGyroRotation() {
            const alpha = deviceRotation.alpha;
            const beta = deviceRotation.beta;
            const gamma = deviceRotation.gamma;
            const orient = THREE.MathUtils.degToRad(screenOrientation);
            const zee = new THREE.Vector3(0, 0, 1);
            const euler = new THREE.Euler(beta, alpha, -gamma, 'YXZ');
            const q0 = new THREE.Quaternion().setFromAxisAngle(zee, -orient);
            sensorQuaternion.setFromEuler(euler);
            sensorQuaternion.multiply(constantRotation);
            sensorQuaternion.multiply(q0);
            perspCamera.quaternion.copy(sensorQuaternion);
        }

        // Joystick Logic
        function setupJoystick() {
            const wrapper = document.getElementById('joystick-wrapper');
            const knob = document.getElementById('joystick-knob');
            const maxRadius = 40;

            const handleTouch = (e) => {
                const touch = e.touches[0];
                const rect = wrapper.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                let dx = touch.clientX - centerX;
                let dy = touch.clientY - centerY;
                
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist > maxRadius) {
                    dx = dx * (maxRadius / dist);
                    dy = dy * (maxRadius / dist);
                }
                
                knob.style.transform = `translate(${dx}px, ${dy}px)`;
                joystick.vector.x = dx / maxRadius;
                joystick.vector.y = dy / maxRadius;
            };

            wrapper.addEventListener('touchstart', (e) => {
                joystick.active = true;
                handleTouch(e);
            });
            wrapper.addEventListener('touchmove', (e) => {
                if (joystick.active) handleTouch(e);
            });
            wrapper.addEventListener('touchend', () => {
                joystick.active = false;
                knob.style.transform = `translate(0px, 0px)`;
                joystick.vector.x = 0;
                joystick.vector.y = 0;
            });
        }

        function setupUI() {
            document.getElementById('btn-load-sample').addEventListener('click', () => loadGLB(GITHUB_SAMPLE_URL));
            const fileInput = document.getElementById('file-input');
            document.getElementById('btn-trigger-file').addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', (e) => {
                if(e.target.files && e.target.files[0]) loadGLB(URL.createObjectURL(e.target.files[0]));
            });
            document.getElementById('btn-home').addEventListener('click', () => location.reload());
            document.getElementById('mode-render').addEventListener('click', () => toggleMode('render'));
            document.getElementById('mode-white').addEventListener('click', () => toggleMode('white'));
            document.getElementById('cam-fly').addEventListener('click', () => switchCam('fly'));
            document.getElementById('cam-walk').addEventListener('click', () => switchCam('walk'));
            document.getElementById('cam-iso').addEventListener('click', () => switchCam('iso'));
            
            document.getElementById('gyro-toggle-btn').addEventListener('click', toggleGyro);

            document.getElementById('btn-reset').addEventListener('click', () => {
                cameraRig.position.set(0, 0, 0); cameraRig.rotation.set(0,0,0);
                perspCamera.position.set(modelMaxDim*1.5, modelMaxDim*1.5, modelMaxDim*1.5);
                perspCamera.quaternion.set(0,0,0,1); oControls.target.set(0,0,0); oControls.update();
            });
            document.getElementById('btn-vr').addEventListener('click', () => {
                const hiddenBtn = document.getElementById('VRButton');
                if(hiddenBtn) hiddenBtn.click();
            });
            document.getElementById('btn-capture').addEventListener('click', () => {
                renderer.render(scene, activeCamera);
                const link = document.createElement('a'); link.download = 'kil_capture.png'; link.href = renderer.domElement.toDataURL('image/png'); link.click();
            });
            const bindClick = (id, fn) => { const el = document.getElementById(id); if(el) el.addEventListener('click', fn); };
            bindClick('bg-sky', () => setBG('sky')); bindClick('bg-solid', () => setBG('solid')); bindClick('bg-hdr', () => setBG('hdr'));
            document.getElementById('bg-color-val').addEventListener('input', (e) => {
                bgColor.set(e.target.value); if(state.bg === 'solid') scene.background = bgColor;
            });
            document.getElementById('toon-weight').addEventListener('input', (e) => {
                const weight = parseFloat(e.target.value);
                if(model) model.traverse(c => { if(c.userData.isEdge) { c.visible = weight > 0; c.material.opacity = Math.min(weight / 2, 1); } });
            });
            document.getElementById('cut-toggle').addEventListener('click', (e) => { 
                state.cutEnabled = !state.cutEnabled; renderer.localClippingEnabled = state.cutEnabled; 
                e.target.classList.toggle('active'); e.target.innerText = state.cutEnabled ? 'ON' : 'OFF'; 
                e.target.style.background = state.cutEnabled ? 'var(--brand-color)' : '#86868b';
            });
            const setAxis = (ax) => { 
                clipAxis = ax; 
                ['axis-x', 'axis-y', 'axis-z'].forEach(id => document.getElementById(id).classList.toggle('active', id === `axis-${ax}`));
                updateClipPlane(document.getElementById('cut-slider').value); 
            };
            bindClick('axis-x', ()=>setAxis('x')); bindClick('axis-y', ()=>setAxis('y')); bindClick('axis-z', ()=>setAxis('z'));
            bindClick('axis-flip', () => { clipNegate = !clipNegate; updateClipPlane(document.getElementById('cut-slider').value); });
            document.getElementById('cut-slider').addEventListener('input', (e)=>updateClipPlane(e.target.value));
            document.getElementById('btn-ai-analyze').addEventListener('click', getAIAnalysis);
        }

        function handleVRController() {
            const session = renderer.xr.getSession();
            if (!session) return;
            for (const source of session.inputSources) {
                if (source.handedness === 'left') continue;
                if (source.handedness === 'right' && source.gamepad) {
                    const gamepad = source.gamepad;
                    const axes = gamepad.axes; 
                    const buttons = gamepad.buttons; 
                    const moveSpeed = 0.05;
                    const rotateSpeed = 0.03;
                    const lookDir = new THREE.Vector3();
                    perspCamera.getWorldDirection(lookDir);
                    lookDir.y = 0; lookDir.normalize();
                    if (Math.abs(axes[3]) > 0.1) cameraRig.position.addScaledVector(lookDir, -axes[3] * moveSpeed);
                    if (Math.abs(axes[2]) > 0.1) cameraRig.rotation.y -= axes[2] * rotateSpeed;
                    if (buttons[5].pressed) { cameraRig.position.set(0, 0, 0); cameraRig.rotation.set(0, 0, 0); }
                    const triggerPressed = buttons[0].pressed;
                    if (triggerPressed) {
                        vrRay.visible = true;
                        const tempMatrix = new THREE.Matrix4();
                        tempMatrix.identity().extractRotation(controllerR.matrixWorld);
                        raycaster.ray.origin.setFromMatrixPosition(controllerR.matrixWorld);
                        raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
                        const intersects = raycaster.intersectObjects(modelGroup.children, true);
                        if (intersects.length > 0) {
                            teleportTarget.position.copy(intersects[0].point);
                            teleportTarget.visible = true;
                            vrRay.scale.z = intersects[0].distance;
                        } else {
                            teleportTarget.visible = false;
                            vrRay.scale.z = 10;
                        }
                    } else {
                        if (vrRay.visible && teleportTarget.visible) cameraRig.position.copy(teleportTarget.position);
                        vrRay.visible = false; teleportTarget.visible = false;
                    }
                }
            }
        }

        function animate() {
            renderer.setAnimationLoop(() => {
                if (renderer.xr.isPresenting) {
                    handleVRController();
                } else {
                    if (isGyroActive && isMobile) {
                        updateGyroRotation();
                    } else if (state.cam === 'iso' || isMobile || !document.pointerLockElement) {
                        oControls.update();
                    }

                    const delta = 0.016;
                    const speed = (state.cam === 'walk' ? 12 : 20) * speedMult;
                    const lookDir = new THREE.Vector3(); perspCamera.getWorldDirection(lookDir);
                    const forward = lookDir.clone(); if(state.cam==='walk') forward.y=0; forward.normalize();
                    const right = new THREE.Vector3().crossVectors(forward, perspCamera.up).normalize();
                    const moveVec = new THREE.Vector3();

                    // Keyboard input
                    if(move.f) moveVec.addScaledVector(forward, speed*delta); 
                    if(move.b) moveVec.addScaledVector(forward, -speed*delta);
                    if(move.l) moveVec.addScaledVector(right, -speed*delta); 
                    if(move.r) moveVec.addScaledVector(right, speed*delta);
                    
                    // Joystick input integration
                    if (isMobile && joystick.active) {
                        moveVec.addScaledVector(forward, -joystick.vector.y * speed * delta);
                        moveVec.addScaledVector(right, joystick.vector.x * speed * delta);
                    }

                    if (moveVec.length() > 0) {
                        if(state.cam === 'fly') {
                            if(move.u) moveVec.y += speed*delta; if(move.d) moveVec.y -= speed*delta;
                            perspCamera.position.add(moveVec);
                        } else if (state.cam === 'walk') {
                            perspCamera.position.x += moveVec.x; perspCamera.position.z += moveVec.z;
                            velocity.y -= 19.6 * delta; perspCamera.position.y += velocity.y * delta;
                            raycaster.set(new THREE.Vector3(perspCamera.position.x, perspCamera.position.y, perspCamera.position.z), new THREE.Vector3(0,-1,0));
                            const hits = raycaster.intersectObjects(modelGroup.children, true);
                            if(hits.length > 0) {
                                const targetY = hits[0].point.y + 1.7;
                                if(Math.abs(targetY - perspCamera.position.y) < 3) {
                                    perspCamera.position.y = THREE.MathUtils.lerp(perspCamera.position.y, targetY, 0.1);
                                    velocity.y = 0; isGrounded = true;
                                }
                            }
                        }
                    }
                }
                renderer.render(scene, activeCamera);
            });
        }

        function applyClipping(m) { if(Array.isArray(m)) m.forEach(x => x.clippingPlanes = [clipPlane]); else m.clippingPlanes = [clipPlane]; }
        function updateClipPlane(val) { 
            const v = parseFloat(val); clipPlane.constant = clipNegate ? v : -v; clipPlane.normal.set(0,0,0); 
            if(clipAxis==='x') clipPlane.normal.x = clipNegate ? -1 : 1; 
            if(clipAxis==='y') clipPlane.normal.y = clipNegate ? -1 : 1; 
            if(clipAxis==='z') clipPlane.normal.z = clipNegate ? -1 : 1; 
        }
        function setBG(type) { 
            state.bg = type; 
            document.getElementById('bg-sky').classList.toggle('active', type==='sky');
            document.getElementById('bg-solid').classList.toggle('active', type==='solid');
            document.getElementById('bg-hdr').classList.toggle('active', type==='hdr');
            document.getElementById('solid-picker-row').style.display = type==='solid'?'flex':'none'; 
            document.getElementById('hdr-upload-row').style.display = type==='hdr'?'flex':'none'; 
            if(type==='sky'){scene.background=skyColor; scene.environment=envTexture;} 
            else if(type==='solid'){scene.background=bgColor; scene.environment=null;} 
            else {scene.background=envTexture; scene.environment=envTexture;} 
        }
        function toggleMode(mode) { 
            state.mode = mode; 
            if(model) model.traverse(c=>{ 
                if(c.isMesh) { 
                    c.material = mode==='render' ? originalMaterials.get(c.uuid) : new THREE.MeshBasicMaterial({color:0xffffff, side:2}); 
                    applyClipping(c.material); 
                } 
            }); 
            document.getElementById('mode-render').classList.toggle('active', mode==='render');
            document.getElementById('mode-white').classList.toggle('active', mode==='white');
        }
        
        function setupEvents() {
            window.addEventListener('resize', () => { 
                renderer.setSize(window.innerWidth, window.innerHeight); 
                perspCamera.aspect = window.innerWidth/window.innerHeight; perspCamera.updateProjectionMatrix(); 
                screenOrientation = window.orientation || 0;
            });
            window.addEventListener('orientationchange', () => { screenOrientation = window.orientation || 0; });
            document.addEventListener('keydown', e => { 
                switch(e.code) { 
                    case 'KeyW': move.f=1; break; case 'KeyS': move.b=1; break; case 'KeyA': move.l=1; break; case 'KeyD': move.r=1; break; 
                    case 'KeyE': move.u=1; break; case 'KeyQ': move.d=1; break; case 'ShiftLeft': speedMult=2; break; 
                } 
            });
            document.addEventListener('keyup', e => { 
                switch(e.code) { 
                    case 'KeyW': move.f=0; break; case 'KeyS': move.b=0; break; case 'KeyA': move.l=0; break; case 'KeyD': move.r=0; 
                    case 'KeyE': move.u=0; break; case 'KeyQ': move.d=0; break; case 'ShiftLeft': speedMult=1; break; 
                } 
            });
            document.addEventListener('mousedown', (e) => { 
                if(!isMobile && document.getElementById('landing-page').style.display === 'none' && !e.target.closest('button, .panel, input') && state.cam !== 'iso' && !isGyroActive) { 
                    pControls.lock(); 
                } 
            });
        }

        function makePanelsDraggable() { document.querySelectorAll('.panel').forEach(p => { const h=p.querySelector('.panel-header'); let isD=false, sx, sy, il, it; h.onmousedown=(e)=>{ isD=true; sx=e.clientX; sy=e.clientY; il=p.offsetLeft; it=p.offsetTop; document.onmousemove=(e)=>{ if(isD) { p.style.left=(il+e.clientX-sx)+'px'; p.style.top=(it+e.clientY-sy)+'px'; } }; document.onmouseup=()=>{ isD=false; document.onmousemove=null; }; }; }); }
        function showToast(m) { const t=document.getElementById('toast'); t.innerText=m; t.style.opacity=1; setTimeout(()=>t.style.opacity=0, 2000); }
        
        async function getAIAnalysis() { 
            if(!model) return; document.getElementById('btn-ai-analyze').innerText="분석 중..."; 
            try { 
                renderer.render(scene, activeCamera); 
                const b64 = renderer.domElement.toDataURL('image/png').split(',')[1]; 
                const p = "건축 전문가로서 이 장면을 분석해줘. 한국어 2문장."; 
                const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({contents:[{parts:[{text:p},{inlineData:{mimeType:"image/png", data:b64}}]}]})}).then(r=>r.json()); 
                document.getElementById('ai-response').innerText = res?.candidates?.[0]?.content?.parts?.[0]?.text || "분석 결과 없음"; 
            } catch(e){ showToast("AI 분석 오류"); } finally { document.getElementById('btn-ai-analyze').innerText="ANALYZE VIEW"; } 
        }
    </script>
</body>
</html>
