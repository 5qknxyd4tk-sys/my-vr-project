<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D GLB Explorer Pro</title>
    <style>
        :root {
            --primary: #007AFF;
            --bg-light: rgba(255, 255, 255, 0.85);
            --border: rgba(0, 0, 0, 0.08);
            --text: #333;
            --shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #ffffff; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; 
            color: var(--text); 
            user-select: none; 
            -webkit-user-select: none; 
            touch-action: none;
        }

        /* 로딩 화면 */
        #landing-page {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: #fff; z-index: 200;
        }
        .upload-box {
            border: 2px dashed #ddd; padding: 60px; border-radius: 24px; text-align: center;
            background: #fafafa; cursor: pointer; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .upload-box:hover { border-color: var(--primary); background: #f0f7ff; transform: translateY(-2px); }
        
        /* UI 패널 */
        .panel {
            position: absolute; left: 20px; width: 240px;
            background: var(--bg-light); backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px);
            border-radius: 16px; box-shadow: var(--shadow);
            border: 1px solid rgba(255,255,255,0.4);
            display: flex; flex-direction: column; transition: all 0.3s; overflow: hidden;
            z-index: 20;
        }
        
        .panel-header {
            padding: 12px 16px; background: rgba(0,0,0,0.03); cursor: move;
            display: flex; justify-content: space-between; align-items: center;
            font-weight: 700; font-size: 11px; color: #666; letter-spacing: 0.05em;
            border-bottom: 1px solid var(--border);
        }
        .panel-content { padding: 16px; display: flex; flex-direction: column; gap: 14px; }
        .panel.minimized .panel-content { display: none; }
        
        #env-panel { top: 80px; }
        #cut-panel { top: 400px; }

        /* 도움말 패널 */
        #help-panel {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 300px; display: none;
        }
        .help-grid { display: grid; grid-template-columns: 1fr 2fr; gap: 8px; font-size: 12px; }
        .key { background: #eee; padding: 2px 6px; border-radius: 4px; font-weight: 700; text-align: center; border-bottom: 2px solid #ccc; }

        /* 컨트롤 요소 */
        button {
            background: #fff; border: 1px solid var(--border); color: #555; padding: 8px 12px; border-radius: 8px;
            cursor: pointer; font-size: 11px; font-weight: 600; transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.02);
            white-space: nowrap;
        }
        button:hover { background: #f8f9fa; border-color: #ccc; color: #000; }
        button.active { background: var(--primary); color: #fff; border-color: var(--primary); }

        input[type=range] { width: 100%; height: 4px; accent-color: var(--primary); cursor: pointer; }
        .row { display: flex; justify-content: space-between; align-items: center; font-size: 11px; color: #666; gap: 10px; }
        .label { font-weight: 600; color: #444; }

        /* 상단 툴바 */
        #top-bar { 
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%); 
            display: flex; gap: 6px; padding: 8px; background: var(--bg-light);
            border-radius: 18px; backdrop-filter: blur(12px); z-index: 100;
            box-shadow: var(--shadow); border: 1px solid rgba(255,255,255,0.5);
            max-width: 95vw; overflow-x: auto; -webkit-overflow-scrolling: touch;
        }
        #top-bar::-webkit-scrollbar { display: none; }

        /* 모바일 이동 패드 */
        #mobile-dpad {
            display: none; position: absolute; left: 30px; bottom: 30px;
            width: 140px; height: 140px; z-index: 100;
            grid-template-areas: ". up ." "left . right" ". down .";
            gap: 10px;
        }
        .dbtn {
            width: 44px; height: 44px; background: var(--bg-light); border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            border: 1px solid var(--border); box-shadow: var(--shadow);
            font-size: 20px; color: var(--primary); cursor: pointer;
        }
        .dbtn:active { background: var(--primary); color: white; }

        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 6px; height: 6px;
            background: var(--primary); border-radius: 50%; transform: translate(-50%, -50%);
            pointer-events: none; display: none; box-shadow: 0 0 10px rgba(0,122,255,0.5); z-index: 1;
        }
        #toast {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); color: white; padding: 10px 20px; border-radius: 25px;
            opacity: 0; transition: opacity 0.4s; font-size: 13px; pointer-events: none; z-index: 1000;
            text-align: center;
        }
        #mobile-menu-btn { display: none; width:44px; height:44px; border-radius:12px; font-size:18px; position: absolute; top: 20px; right: 20px; z-index: 101; }

        #btn-ar { display: none; color: #FF2D55; border-color: #FF2D55; }
        #btn-gyro.active { background: #5856D6; border-color: #5856D6; color: white; }

        @media (max-width: 768px) {
            .panel { display: none; }
            #mobile-menu-btn { display: block; }
            #mobile-dpad.active { display: grid; }
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="landing-page">
        <div class="upload-box" onclick="document.getElementById('file-input').click()">
            <h1 style="margin:0; font-size:24px; font-weight:800; color:#222; letter-spacing:-0.02em;">3D GLB Explorer</h1>
            <p style="font-size:13px; color:#888; margin-top:8px;">클릭하여 GLB 모델을 선택하세요</p>
            <input type="file" id="file-input" accept=".glb,.gltf" style="display:none;">
        </div>
    </div>

    <div id="ui-layer" style="display:none;">
        <div id="crosshair"></div>
        <button id="mobile-menu-btn" onclick="toggleMobileSettings()">⚙</button>

        <div id="top-bar">
            <button id="mode-render" class="active">RENDER</button>
            <button id="mode-white">WHITE</button>
            <span style="width:1px; height:16px; background:#ddd; margin:auto 4px; flex-shrink:0;"></span>
            <button id="cam-fly" class="active">FLY</button>
            <button id="cam-walk">WALK</button>
            <button id="cam-iso">ISO</button>
            <span style="width:1px; height:16px; background:#ddd; margin:auto 4px; flex-shrink:0;"></span>
            <button id="btn-reset">RESET</button>
            <button id="btn-gyro">GYRO</button>
            <button id="btn-ar">AR VIEW</button>
            <button id="btn-help">GUIDE</button>
            <button id="btn-capture" style="color:var(--primary)">CAPTURE</button>
        </div>

        <div id="mobile-dpad">
            <div class="dbtn" style="grid-area: up;" id="d-up">↑</div>
            <div class="dbtn" style="grid-area: left;" id="d-left">←</div>
            <div class="dbtn" style="grid-area: right;" id="d-right">→</div>
            <div class="dbtn" style="grid-area: down;" id="d-down">↓</div>
        </div>

        <div id="help-panel" class="panel">
            <div class="panel-header">CONTROLS <button id="close-help" style="border:none;background:none;font-size:14px;padding:0">×</button></div>
            <div class="panel-content">
                <div class="help-grid">
                    <span class="key">W A S D</span><span>이동</span>
                    <span class="key">E / Q</span><span>상승 / 하강</span>
                    <span class="key">SHIFT</span><span>가속</span>
                    <span class="key">SPACE</span><span>점프 (Walk)</span>
                    <span class="key">GYRO</span><span>기기 회전 시점 조작</span>
                </div>
            </div>
        </div>

        <div id="env-panel" class="panel">
            <div class="panel-header">LIGHTING & SKY <button class="toggle-btn" style="border:none;background:none;font-size:14px;padding:0">－</button></div>
            <div class="panel-content">
                <div class="row">
                    <span class="label">Sky Type</span>
                    <div style="display:flex; gap:4px; flex:1; margin-left:10px;">
                        <button id="bg-hdri" class="active" style="flex:1;">REAL</button>
                        <button id="bg-color" style="flex:1;">SOLID</button>
                    </div>
                </div>
                <div class="row" id="hdr-load-row">
                    <span class="label">HDR Load</span>
                    <button onclick="document.getElementById('hdr-input').click()" style="flex:1">IMPORT .HDR</button>
                    <input type="file" id="hdr-input" accept=".hdr,.exr" style="display:none;">
                </div>
                <div class="row" id="bg-color-picker-row" style="display:none;">
                    <span class="label">Custom Color</span>
                    <input type="color" id="bg-color-val" value="#ffffff" style="width:40px; height:24px; border:none; padding:0; background:none; cursor:pointer;">
                </div>
                <div class="row">
                    <span class="label">Intensity</span>
                    <input type="range" id="sun-intensity" min="0" max="10" step="0.1" value="3.5">
                </div>
                <div class="row">
                    <span class="label">Angle</span>
                    <input type="range" id="sun-angle" min="0" max="360" value="145">
                </div>
            </div>
        </div>

        <div id="cut-panel" class="panel">
            <div class="panel-header">SECTION ANALYSIS <button class="toggle-btn" style="border:none;background:none;font-size:14px;padding:0">－</button></div>
            <div class="panel-content">
                <div class="row">
                    <span class="label">Active</span>
                    <button id="cut-toggle" class="active" style="width:60px;">ON</button>
                </div>
                <div class="row" style="gap:4px;">
                    <button id="axis-x" class="axis-btn" style="flex:1">X</button>
                    <button id="axis-y" class="axis-btn active" style="flex:1">Y</button>
                    <button id="axis-z" class="axis-btn" style="flex:1">Z</button>
                    <button id="axis-flip" style="color:var(--primary)">FLIP</button>
                </div>
                <div class="row">
                    <span class="label">Offset</span>
                    <input type="range" id="cut-slider" min="-100" max="100" value="100">
                </div>
                <div class="row">
                    <span class="label">Cut Color</span>
                    <input type="color" id="cut-color" value="#007AFF" style="width:40px; height:24px; border:none; padding:0; background:none; cursor:pointer;"> 
                </div>
            </div>
        </div>

        <div id="toast">Message</div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

        let scene, renderer, perspCamera, orthoCamera, activeCamera, pControls, oControls;
        let model = null, modelGroup = new THREE.Group();
        let originalMaterials = new Map();
        let envTexture, bgColor = new THREE.Color(0xffffff), skyColor = new THREE.Color(0x87CEEB);
        let sunLight, hemiLight, ambientLight;
        
        let initialCamPos = new THREE.Vector3(20, 20, 20);
        let initialCamRot = new THREE.Euler();

        const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
        const clipPlane = new THREE.Plane(new THREE.Vector3(0, -1, 0), 100);
        let clipAxis = 'y', clipNegate = true, cutLineColor = new THREE.Color(0x007AFF);
        const state = { mode: 'render', cam: 'fly', bg: 'sky', cutEnabled: true, gyro: false };

        const velocity = new THREE.Vector3(), direction = new THREE.Vector3(), move = { f:0, b:0, l:0, r:0, u:0, d:0 };
        let speedMult = 1;
        const raycaster = new THREE.Raycaster();

        // 자이로용 변수들
        let gyroQuaternion = new THREE.Quaternion();
        const baseQuaternion = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)); // 기기 보정

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = skyColor; 
            scene.add(modelGroup);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.localClippingEnabled = true; 
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 1.3;
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            const roomEnv = new RoomEnvironment();
            envTexture = pmremGenerator.fromScene(roomEnv, 0.04).texture;
            scene.environment = envTexture;

            const aspect = window.innerWidth / window.innerHeight;
            perspCamera = new THREE.PerspectiveCamera(60, aspect, 0.1, 10000);
            perspCamera.position.copy(initialCamPos);

            const frustum = 30;
            orthoCamera = new THREE.OrthographicCamera(-frustum*aspect, frustum*aspect, frustum, -frustum, 0.1, 10000);
            orthoCamera.position.set(50, 50, 50);
            orthoCamera.lookAt(0, 0, 0);
            activeCamera = perspCamera;

            ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 1.2);
            scene.add(hemiLight);
            sunLight = new THREE.DirectionalLight(0xffffff, 3.5);
            sunLight.position.set(30, 50, 30);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.set(2048, 2048);
            scene.add(sunLight);

            pControls = new PointerLockControls(perspCamera, document.body);
            oControls = new OrbitControls(perspCamera, renderer.domElement);
            oControls.enableDamping = true;
            oControls.screenSpacePanning = true;

            setupEvents();
            setupUI();
            setupMobileDpad();
            makePanelsDraggable();
            
            switchCam('fly');
        }

        function loadGLB(url) {
            new GLTFLoader().load(url, (gltf) => {
                if(model) modelGroup.remove(model);
                model = gltf.scene;
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                model.position.sub(center); 
                model.traverse(c => {
                    if(c.isMesh) {
                        c.castShadow = true; c.receiveShadow = true;
                        originalMaterials.set(c.uuid, c.material);
                        applyClipping(c.material);
                        const edges = new THREE.EdgesGeometry(c.geometry, 25);
                        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, polygonOffset: true, polygonOffsetFactor: -1, polygonOffsetUnits: -1 }));
                        line.material.clippingPlanes = [clipPlane];
                        line.visible = false; line.userData.isEdge = true;
                        c.add(line); 
                    }
                });
                modelGroup.add(model);
                const maxDim = Math.max(size.x, size.y, size.z);
                const slider = document.getElementById('cut-slider');
                slider.min = -maxDim; slider.max = maxDim; slider.value = maxDim;
                updateClipPlane(slider.value);
                document.getElementById('landing-page').style.display = 'none';
                document.getElementById('ui-layer').style.display = 'block';
                oControls.target.set(0, 0, 0);
                initialCamPos.copy(perspCamera.position);
                initialCamRot.copy(perspCamera.rotation);
                showToast("모델이 로드되었습니다.");
            });
        }

        function loadHDR(url) {
            showToast("환경 정보를 불러오는 중...");
            new RGBELoader().load(url, (texture) => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                envTexture = texture;
                if (state.mode === 'render') {
                    scene.environment = envTexture;
                    if (state.bg === 'sky') scene.background = envTexture;
                }
                showToast("HDR이 적용되었습니다.");
            });
        }

        function applyClipping(m) {
            if(Array.isArray(m)) m.forEach(x => x.clippingPlanes = [clipPlane]);
            else m.clippingPlanes = [clipPlane];
        }

        function updateClipPlane(val) {
            const v = parseFloat(val);
            clipPlane.constant = clipNegate ? v : -v;
            clipPlane.normal.set(0,0,0);
            const dir = clipNegate ? -1 : 1;
            if(clipAxis === 'x') clipPlane.normal.x = dir;
            if(clipAxis === 'y') clipPlane.normal.y = dir;
            if(clipAxis === 'z') clipPlane.normal.z = dir;
        }

        const whiteMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 1.0, metalness: 0.0, side: THREE.DoubleSide });

        function toggleMode(mode) {
            state.mode = mode;
            const isRender = mode === 'render';
            document.getElementById('mode-render').classList.toggle('active', isRender);
            document.getElementById('mode-white').classList.toggle('active', !isRender);
            if (!isRender) {
                scene.background = new THREE.Color(0xffffff);
                scene.environment = null;
                ambientLight.intensity = 1.8; hemiLight.intensity = 2.0; sunLight.intensity = 2.5;
            } else {
                scene.background = (state.bg === 'sky') ? (envTexture && envTexture.isTexture ? envTexture : skyColor) : bgColor;
                scene.environment = envTexture;
                ambientLight.intensity = 0.8; hemiLight.intensity = 1.2; sunLight.intensity = 3.5;
            }
            if(!model) return;
            model.traverse(c => {
                if(c.isMesh) {
                    c.material = isRender ? originalMaterials.get(c.uuid) : whiteMaterial.clone();
                    applyClipping(c.material);
                    c.children.forEach(ch => { if(ch.userData.isEdge) { ch.visible = !isRender; ch.material.color.set(0x000000); } });
                }
            });
        }

        function setupEvents() {
            window.addEventListener('resize', () => {
                const aspect = window.innerWidth/window.innerHeight;
                perspCamera.aspect = aspect; perspCamera.updateProjectionMatrix();
                orthoCamera.left = -30*aspect; orthoCamera.right = 30*aspect; orthoCamera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            document.addEventListener('keydown', e => {
                switch(e.code) {
                    case 'KeyW': move.f = 1; break; case 'KeyS': move.b = 1; break;
                    case 'KeyA': move.l = 1; break; case 'KeyD': move.r = 1; break;
                    case 'KeyE': move.u = 1; break; case 'KeyQ': move.d = 1; break;
                    case 'ShiftLeft': speedMult = 2.5; break;
                    case 'Space': if(state.cam === 'walk' && velocity.y <= 0) velocity.y += 10; break;
                }
            });
            document.addEventListener('keyup', e => {
                switch(e.code) {
                    case 'KeyW': move.f = 0; break; case 'KeyS': move.b = 0; break;
                    case 'KeyA': move.l = 0; break; case 'KeyD': move.r = 0; break;
                    case 'KeyE': move.u = 0; break; case 'KeyQ': move.d = 0; break;
                    case 'ShiftLeft': speedMult = 1; break;
                }
            });
            
            // 자이로 이벤트 핸들러
            window.addEventListener('deviceorientation', (e) => {
                if (!state.gyro) return;
                const alpha = e.alpha ? THREE.MathUtils.degToRad(e.alpha) : 0;
                const beta = e.beta ? THREE.MathUtils.degToRad(e.beta) : 0;
                const gamma = e.gamma ? THREE.MathUtils.degToRad(e.gamma) : 0;
                
                const euler = new THREE.Euler(beta, alpha, -gamma, 'YXZ');
                gyroQuaternion.setFromEuler(euler);
                perspCamera.quaternion.copy(baseQuaternion).multiply(gyroQuaternion);
            });

            if(!isMobile) {
                document.addEventListener('click', (e) => {
                    if(e.target.closest('button') || e.target.closest('input') || e.target.closest('.panel')) return;
                    
                    // Pointer Lock 보안 예외 처리
                    if(state.cam !== 'iso' && !pControls.isLocked && !state.gyro && !document.pointerLockElement) {
                        try {
                            const promise = pControls.lock();
                            if (promise instanceof Promise) {
                                promise.catch(err => {
                                    if (err.name !== 'NotAllowedError' && err.name !== 'SecurityError') {
                                        console.warn("PointerLock rejection:", err);
                                    }
                                });
                            }
                        } catch (err) {
                            // 동기적 에러 발생 시 무시
                        }
                    }
                });

                // Pointer Lock 에러 전역 핸들러
                document.addEventListener('pointerlockerror', () => {
                    console.warn("Pointer Lock Error: 브라우저 환경에 의해 마우스 잠금이 제한되었습니다.");
                    showToast("Camera lock restricted.");
                });
            }
        }

        function setupMobileDpad() {
            const bind = (id, key) => {
                const el = document.getElementById(id);
                el.addEventListener('touchstart', (e) => { e.preventDefault(); move[key] = 1; });
                el.addEventListener('touchend', (e) => { e.preventDefault(); move[key] = 0; });
            };
            bind('d-up', 'f'); bind('d-down', 'b'); bind('d-left', 'l'); bind('d-right', 'r');
        }

        function switchCam(mode) {
            state.cam = mode;
            ['cam-fly','cam-walk','cam-iso'].forEach(id => {
                const btn = document.getElementById(id);
                if (btn) btn.classList.toggle('active', id === `cam-${mode}`);
            });
            
            const isIso = mode === 'iso';
            const isWalk = mode === 'walk';
            document.getElementById('crosshair').style.display = isIso ? 'none' : 'block';
            
            if(isMobile) {
                document.getElementById('mobile-dpad').classList.toggle('active', !isIso);
                document.getElementById('btn-ar').style.display = isWalk ? 'inline-block' : 'none';
            }
            
            if(isIso) {
                activeCamera = orthoCamera; oControls.object = orthoCamera; oControls.enabled = true;
                if(!isMobile && pControls.isLocked) pControls.unlock();
                disableGyro();
            } else {
                activeCamera = perspCamera; oControls.object = perspCamera; oControls.enabled = isMobile && !state.gyro ? true : false;
            }
            showToast(`모드: ${mode.toUpperCase()}`);
        }

        function toggleGyro() {
            if (!isMobile) { showToast("자이로 모드는 모바일에서만 지원됩니다."); return; }
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission().then(res => {
                    if (res === 'granted') applyGyroState();
                    else showToast("센서 사용 권한이 필요합니다.");
                }).catch(() => showToast("권한 요청에 실패했습니다."));
            } else {
                applyGyroState();
            }
        }

        function applyGyroState() {
            state.gyro = !state.gyro;
            document.getElementById('btn-gyro').classList.toggle('active', state.gyro);
            if (state.gyro) {
                oControls.enabled = false;
                showToast("자이로 뷰 활성화");
            } else {
                disableGyro();
            }
        }

        function disableGyro() {
            state.gyro = false;
            const btn = document.getElementById('btn-gyro');
            if (btn) btn.classList.remove('active');
            if (isMobile && state.cam !== 'iso') oControls.enabled = true;
        }

        function setupUI() {
            document.getElementById('file-input').onchange = (e) => {
                if (e.target.files[0]) loadGLB(URL.createObjectURL(e.target.files[0]));
            };
            document.getElementById('hdr-input').onchange = (e) => {
                if (e.target.files[0]) loadHDR(URL.createObjectURL(e.target.files[0]));
            };
            
            document.getElementById('mode-render').onclick = () => toggleMode('render');
            document.getElementById('mode-white').onclick = () => toggleMode('white');
            document.getElementById('cam-fly').onclick = () => switchCam('fly');
            document.getElementById('cam-walk').onclick = () => switchCam('walk');
            document.getElementById('cam-iso').onclick = () => switchCam('iso');
            
            document.getElementById('btn-reset').onclick = () => {
                perspCamera.position.copy(initialCamPos); perspCamera.rotation.copy(initialCamRot);
                oControls.target.set(0, 0, 0); velocity.set(0,0,0); showToast("카메라 리셋");
            };
            
            document.getElementById('btn-gyro').onclick = () => toggleGyro();
            
            document.getElementById('btn-ar').onclick = () => {
                if (!navigator.xr) { showToast("AR 미지원 브라우저입니다."); return; }
                navigator.xr.isSessionSupported('immersive-ar').then(supported => {
                    if (supported) {
                        renderer.xr.setReferenceSpaceType('local');
                        navigator.xr.requestSession('immersive-ar', { 
                            optionalFeatures: ['local-floor', 'dom-overlay'], 
                            domOverlay: { root: document.body } 
                        }).then(s => renderer.xr.setSession(s)).catch(() => showToast("AR 세션 시작 실패"));
                    } else { showToast("AR을 사용할 수 없습니다."); }
                });
            };
            
            document.getElementById('btn-help').onclick = () => document.getElementById('help-panel').style.display = 'flex';
            document.getElementById('close-help').onclick = () => document.getElementById('help-panel').style.display = 'none';
            
            document.getElementById('btn-capture').onclick = () => {
                renderer.render(scene, activeCamera);
                const dataURL = renderer.domElement.toDataURL('image/png');
                const link = document.createElement('a'); link.download = 'Explorer_Capture.png'; link.href = dataURL; link.click();
                showToast("스크린샷 저장");
            };
            
            document.getElementById('bg-hdri').onclick = (e) => { 
                state.bg='sky'; if (state.mode === 'render') scene.background = envTexture && envTexture.isTexture ? envTexture : skyColor;
                e.target.classList.add('active'); document.getElementById('bg-color').classList.remove('active');
            };
            document.getElementById('bg-color').onclick = (e) => { 
                state.bg='color'; if (state.mode === 'render') scene.background = bgColor;
                e.target.classList.add('active'); document.getElementById('bg-hdri').classList.remove('active');
            };
            document.getElementById('bg-color-val').oninput = (e) => { 
                bgColor.set(e.target.value); if (state.mode === 'render' && state.bg === 'color') scene.background = bgColor; 
            };
            
            document.getElementById('sun-intensity').oninput = (e) => sunLight.intensity = parseFloat(e.target.value);
            document.getElementById('sun-angle').oninput = (e) => {
                const rad = e.target.value * (Math.PI/180);
                sunLight.position.x = Math.sin(rad) * 40; sunLight.position.z = Math.cos(rad) * 40;
            };
            
            document.getElementById('cut-toggle').onclick = (e) => { 
                state.cutEnabled = !state.cutEnabled; renderer.localClippingEnabled = state.cutEnabled; e.target.classList.toggle('active'); 
            };
            
            const setAxis = (ax) => { clipAxis = ax; ['axis-x', 'axis-y', 'axis-z'].forEach(id => document.getElementById(id).classList.toggle('active', id === `axis-${ax}`)); updateClipPlane(document.getElementById('cut-slider').value); };
            document.getElementById('axis-x').onclick = () => setAxis('x');
            document.getElementById('axis-y').onclick = () => setAxis('y');
            document.getElementById('axis-z').onclick = () => setAxis('z');
            document.getElementById('axis-flip').onclick = () => { clipNegate = !clipNegate; updateClipPlane(document.getElementById('cut-slider').value); };
            document.getElementById('cut-slider').oninput = (e) => updateClipPlane(e.target.value);
            document.getElementById('cut-color').oninput = (e) => {
                const newColorStr = e.target.value;
                cutLineColor.set(newColorStr);
                if(model && state.mode === 'render') {
                    model.traverse(c => { c.children.forEach(ch => { if(ch.userData.isEdge) ch.material.color.copy(cutLineColor); }); });
                }
            };
        }

        function makePanelsDraggable() {
            document.querySelectorAll('.panel').forEach(panel => {
                const header = panel.querySelector('.panel-header');
                const toggle = panel.querySelector('.toggle-btn');
                if(toggle) toggle.onclick = (e) => { e.stopPropagation(); panel.classList.toggle('minimized'); toggle.innerText = panel.classList.contains('minimized') ? '＋' : '－'; };
                let isDragging = false, startX, startY, initLeft, initTop;
                header.onmousedown = (e) => {
                    isDragging = true; startX = e.clientX; startY = e.clientY;
                    initLeft = panel.offsetLeft; initTop = panel.offsetTop;
                    document.onmousemove = (e) => { if(!isDragging) return; panel.style.left = (initLeft + e.clientX - startX) + 'px'; panel.style.top = (initTop + e.clientY - startY) + 'px'; };
                    document.onmouseup = () => { isDragging = false; document.onmousemove = null; };
                };
            });
        }

        function animate() {
            renderer.setAnimationLoop(() => {
                if(oControls.enabled && !state.gyro) oControls.update();

                if(state.cam==='fly'||state.cam==='walk') {
                    const delta = 0.016;
                    velocity.x -= velocity.x * 10.0 * delta; velocity.z -= velocity.z * 10.0 * delta; velocity.y -= velocity.y * 10.0 * delta;
                    direction.z = Number(move.f) - Number(move.b); direction.x = Number(move.r) - Number(move.l); direction.normalize();
                    const speed = (state.cam === 'walk' ? 40 : 60) * speedMult;
                    if (move.f || move.b || move.l || move.r) { velocity.z -= direction.z * speed * delta; velocity.x -= direction.x * speed * delta; }
                    
                    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(activeCamera.quaternion);
                    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(activeCamera.quaternion);
                    if (state.cam === 'walk') { forward.y = 0; right.y = 0; forward.normalize(); right.normalize(); }
                    
                    activeCamera.position.addScaledVector(forward, -velocity.z * delta);
                    activeCamera.position.addScaledVector(right, -velocity.x * delta);
                    
                    if(state.cam === 'fly') { if(move.u) velocity.y += speed * delta; if(move.d) velocity.y -= speed * delta; activeCamera.position.y += velocity.y * delta; }
                    if(state.cam === 'walk') {
                        velocity.y -= 9.8 * 6.0 * delta;
                        raycaster.set(activeCamera.position, new THREE.Vector3(0, -1, 0));
                        const intersects = raycaster.intersectObjects(modelGroup.children, true);
                        if (intersects.length > 0) { const dist = intersects[0].distance; if (dist < 1.7) { activeCamera.position.y = intersects[0].point.y + 1.7; velocity.y = Math.max(0, velocity.y); } }
                        activeCamera.position.y += velocity.y * delta;
                    }
                    if (isMobile && !state.gyro) { const lookDir = new THREE.Vector3(0, 0, -1).applyQuaternion(activeCamera.quaternion); oControls.target.copy(activeCamera.position).add(lookDir); }
                }
                renderer.render(scene, activeCamera);
            });
        }

        window.toggleMobileSettings = () => {
            const panels = document.querySelectorAll('.panel');
            const isHidden = panels[0].style.display === 'none' || panels[0].style.display === '';
            panels.forEach(p => p.style.display = isHidden ? 'flex' : 'none');
        };

        function showToast(msg) {
            const t = document.getElementById('toast');
            t.innerText = msg; t.style.opacity = 1;
            setTimeout(() => t.style.opacity = 0, 4000);
        }
    </script>
</body>
</html>
